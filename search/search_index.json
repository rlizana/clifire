{"config":{"lang":["en","es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"en/","title":"CliFire","text":"<p>Minimal CLI framework to build Python commands quickly and elegantly.</p> <p>CliFire is a lightweight library designed to simplify the creation of command line interfaces (CLI). It allows developers to define commands, options, and arguments easily, facilitating the building of complex CLI applications without the overhead of larger frameworks.</p> <p>The idea behind CliFire is to enable you to create CLIs quickly and effortlessly by leveraging Python's features. Its minimalist approach and intuitive syntax make it easy to learn and use, allowing developers to focus on the logic of their applications rather than on CLI infrastructure.</p> <p>Additionally, with the <code>fire</code> command, you can create dynamic commands directly from the terminal, providing an interactive and flexible experience.</p>"},{"location":"en/#main-features","title":"Main Features","text":"<ul> <li>Two usage styles: decorators for a simple approach or classes for greater customization.</li> <li>Intuitive syntax: focused on simplicity and readability.</li> <li>Global and per-command options: flexible parameter configuration.</li> <li>Grouped commands: organizes related commands hierarchically.</li> <li>Formatted output: uses Rich to display messages with colors and styles.</li> <li>Built-in templates: creates files using Jinja2.</li> <li>Centralized configuration: easily manage your application's configuration.</li> </ul>"},{"location":"en/#quick-installation","title":"Quick Installation","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"en/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"en/changelog/#011-2025-06-07","title":"[0.1.1] - 2025-06-07","text":""},{"location":"en/changelog/#added","title":"Added","text":"<ul> <li>Bash command <code>clifire</code>  for creating dynamic commands.</li> <li>In application module, added:</li> <li>Global option <code>--verbose</code> created by default.</li> <li>If no command is passed, help is shown if the help command is defined.</li> <li>New <code>path</code> method for get absolute path to a filename.</li> <li>New <code>config</code> variable for managing configuration settings.</li> <li>New <code>template</code> variable for creating files with jinja2.</li> <li>In out module, added:</li> <li><code>debug</code> method for printing debug messages.</li> <li><code>debug2</code> method for printing debug messages level 2.</li> <li><code>var_dump</code> method for printing pretty variables in out module.</li> <li>New <code>Config</code> class to manage configuration settings.</li> <li>New <code>Template</code> class for creating files with jinja2.</li> <li>Changed relative imports to module imports for better compatibility.</li> </ul>"},{"location":"en/changelog/#changed","title":"Changed","text":"<ul> <li>Commands now use <code>fire()</code> method instead of <code>run()</code>.</li> <li>Compatibility with Python 3.10.</li> <li>Updated documentation to include usage examples for the new <code>clifire</code> command.</li> <li>Enhanced the <code>--verbose</code> option to provide more detailed output during command execution.</li> <li>Improved Result class, stdout and stderr are now str instead of list</li> </ul>"},{"location":"en/changelog/#fixed","title":"Fixed","text":"<ul> <li>The arguments between quotes are now correctly parsed, allowing for spaces in arguments.</li> <li>The [options] message in <code>help</code> command not correctly displayed.</li> </ul>"},{"location":"en/changelog/#removed","title":"Removed","text":""},{"location":"en/changelog/#010-2025-06-01","title":"[0.1.0] - 2025-06-01","text":""},{"location":"en/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release with the first usable version.</li> </ul>"},{"location":"en/contributing/","title":"Contribute to CliFire","text":"<p>Thank you for your interest in contributing to CliFire!</p> <p>Contributions are welcome and help improve this minimalistic project designed to build CLI applications in Python.</p>"},{"location":"en/contributing/#how-to-contribute","title":"How to Contribute","text":"<p>There are several ways you can help:</p> <ul> <li>Reporting Bugs: If you find a bug or unexpected behavior, please open an issue on GitHub with a detailed description and, if possible, steps to reproduce it.</li> <li>Requesting New Features: If you have an idea to improve CliFire, open an issue or propose a pull request.</li> <li>Code and Improvements: If you wish to submit code, make sure you follow the project's style guidelines and add unit tests to support your changes.</li> <li>Documentation: Help improve the documentation by correcting errors, expanding sections, or adding usage examples.</li> </ul>"},{"location":"en/contributing/#contribution-workflow","title":"Contribution Workflow","text":""},{"location":"en/contributing/#fork-the-repository","title":"Fork the Repository","text":"<p>Fork the project on GitHub.</p>"},{"location":"en/contributing/#clone-your-fork-locally","title":"Clone your fork locally:","text":"<pre><code>git clone https://github.com/your-user/clifire.git\ncd clifire\n</code></pre>"},{"location":"en/contributing/#create-a-branch-for-your-changes","title":"Create a Branch for your Changes:","text":"<pre><code>git checkout -b my-changes\n</code></pre>"},{"location":"en/contributing/#make-your-changes","title":"Make your Changes:","text":"<p>Make the necessary changes in the code. Ensure that:</p> <ul> <li>You follow the project's style guidelines.</li> <li>You add unit tests\u2014the project has 100% coverage!</li> <li>You update or add documentation where necessary.</li> </ul>"},{"location":"en/contributing/#run-the-tests","title":"Run the Tests:","text":"<p>Make sure all tests pass using:    <pre><code>poetry run pytest\n</code></pre>    Check the coverage with:    <pre><code>poetry run coverage run -m pytest &amp;&amp; poetry run coverage html\n</code></pre></p> <p>You can also use <code>poetry run fire coverage</code> to run the tests and generate the coverage report.</p>"},{"location":"en/contributing/#submit-a-pull-request","title":"Submit a Pull Request:","text":"<p>Once you are satisfied with your changes, submit a pull request to the main branch of the repository. Describe in detail what you have changed and the motivation behind it.</p>"},{"location":"en/contributing/#best-practices","title":"Best Practices","text":"<ul> <li>Write clear and descriptive commit messages.</li> <li>Follow the Keep a Changelog format to document your changes.</li> <li>Ensure that new features or fixes do not break existing compatibility.</li> <li>Respect the format and structure of the existing documentation.</li> </ul>"},{"location":"en/contributing/#review-and-feedback","title":"Review and Feedback","text":"<p>Your pull request will be reviewed by the project maintainers. They may ask for adjustments or clarifications, so please pay close attention to any comments!</p> <p>For further details, refer to the Complete Contribution Guide in the repository.</p> <p>Thank you for helping CliFire grow and improve!</p>"},{"location":"en/quick-start/","title":"Quick Start Guide - Getting Started with CliFire","text":"<p>Welcome to the Quick Start Guide for CliFire, a minimalist framework for creating command line interfaces in Python quickly and elegantly.</p>"},{"location":"en/quick-start/#installation","title":"Installation","text":"<p>You can install CliFire from PyPI or directly using Poetry:</p>"},{"location":"en/quick-start/#from-pypi","title":"From PyPI","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"en/quick-start/#using-poetry","title":"Using Poetry","text":"<pre><code>poetry add clifire\n</code></pre>"},{"location":"en/quick-start/#basic-usage","title":"Basic Usage","text":"<p>CliFire allows you to define commands using decorators or classes. Here\u2019s an example using a decorator to greet the user:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre>"},{"location":"en/quick-start/#running-the-command","title":"Running the Command","text":"<p>Save the file as <code>fire.py</code> or create a <code>fire</code> directory and place the file inside with a <code>.py</code> extension.</p> <p>Help is automatically built from the docstring, allowing users to quickly understand how to use the command:</p> <p></p> <p>You can run the <code>greet</code> command directly: </p>"},{"location":"en/quick-start/#main-features","title":"Main Features","text":"<ul> <li>Simple Command Definition: Use decorators or classes to create dynamic commands.</li> <li>Handling of Arguments and Options: Define arguments and options to customize the behavior of your commands.</li> <li>Formatted Output: Uses the <code>out</code> module to display messages with styles and colors by leveraging the Rich library.</li> <li>Centralized Configuration: Manage your application's configuration through the <code>Config</code> class.</li> <li>File Templates: Create files using Jinja2 templates via the <code>Template</code> class.</li> </ul>"},{"location":"en/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>For more details on the API and configuration, consult the User Documentation.</li> <li>Check the API Reference to see all available functions and classes.</li> <li>Look at practical examples in the Examples section.</li> </ul> <p>Start creating your commands and enjoy a minimalist and powerful experience with CliFire!</p>"},{"location":"en/user-guide/basics/","title":"CliFire Basics","text":"<p>CliFire is a minimalist framework for creating command line applications in Python in a simple and elegant way. This guide introduces you to the fundamental concepts so you can start using it quickly.</p> <p>We offer two approaches to use CliFire, via decorators or via classes:</p> <ul> <li>Decorators: They allow you to define commands quickly and easily without losing power or flexibility.</li> <li>Classes: They offer more detailed control over a command\u2019s behavior, ideal for more complex applications.</li> </ul> <p>The idea behind CliFire is to enable you to create CLI (Command Line Interface) applications quickly and easily by leveraging Python's features.</p>"},{"location":"en/user-guide/basics/#1-commands","title":"1. Commands","text":"<p>Commands are the essence of your CLI application. You can define them in two ways:</p> <ul> <li>Using decorators:   Command creation is simplified with the <code>@command.fire</code> decorator.</li> </ul> <pre><code>from clifire import command, out\n\n@command.fire\ndef hello(cmd, name: str = \"World\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user. Defaults to \"World\".\n    \"\"\"\n    out.info(f\"Hello, {name}!\")\n</code></pre> <ul> <li>Using classes:   Create a class that inherits from <code>command.Command</code> for more control over the command's behavior.</li> </ul> <pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    def fire(self):\n        out.info(\"Executing test command\")\n</code></pre>"},{"location":"en/user-guide/basics/#2-arguments-and-options","title":"2. Arguments and Options","text":"<p>CliFire allows you to define:</p> <ul> <li>Global Options: Settings that affect the entire application (for example, verbose mode).</li> <li>Local Options: Specific arguments and options for each command.</li> </ul> <p>These options can be set using the <code>Field</code> class from the <code>command</code> module.</p> <pre><code>from clifire import command\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    bool_option = command.Field(\n        pos=1,\n        help=\"Example boolean option\",\n        default=False,\n        alias=[\"-v\"],\n    )\n\n    def fire(self):\n        if self.bool_option:\n            print(\"Verbose option enabled\")\n        else:\n            print(\"Verbose option disabled\")\n</code></pre>"},{"location":"en/user-guide/basics/#3-configuration","title":"3. Configuration","text":"<p>The <code>Config</code> class manages your application's configuration. It allows you to read data from YAML files and write it, excluding private fields (those that begin with <code>_</code>).</p> <pre><code>from clifire import config\n\nconf = config.Config(config_file=\"config.yaml\")\nconf.name = \"MyApp\"\nconf.version = \"1.0.0\"\nconf.write()\n</code></pre> <p>Note: Private fields (e.g., <code>_secret</code>) are not saved in the configuration file.</p>"},{"location":"en/user-guide/basics/#4-output-and-styling","title":"4. Output and Styling","text":"<p>The <code>out</code> module uses the Rich library to display messages with different styles and colors:</p> <ul> <li><code>out.info()</code>: Information.</li> <li><code>out.success()</code>: Success.</li> <li><code>out.warn()</code>: Warning.</li> <li><code>out.error()</code>: Error.</li> </ul> <pre><code>from clifire import out\n\nout.info(\"This is an informational message\")\n</code></pre>"},{"location":"en/user-guide/basics/#5-templates","title":"5. Templates","text":"<p>The <code>Template</code> class allows you to generate files from Jinja2 templates. This is useful for creating files with dynamic content in an easy way.</p> <pre><code>from clifire import template\n\ntpl = template.Template(template_folder=\"templates\")\ncontent = tpl.render(\n    \"sample.jinja2\",\n    title=\"My Title\",\n    user=\"admin\",\n    items=[\"data1\", \"data2\"]\n)\n</code></pre> <p>Moreover, the <code>write</code> function of the template lets you save the rendered content to a file, with the option to insert or replace content delimited by markers.</p> <p>This is useful for generating configuration files or custom scripts that can be easily updated in the future without affecting the rest of the file.</p>"},{"location":"en/user-guide/basics/#6-execution-flow","title":"6. Execution Flow","text":"<ol> <li> <p>Command Definition:    Commands are defined using decorators or classes.</p> </li> <li> <p>Command Registration:    When the <code>App</code> is instantiated, commands are registered. By default, a help command is added that shows information about all available commands.</p> </li> <li> <p>Parsing and Execution:    When the application is run, the command line is parsed, the command to execute is identified, and its options and arguments are processed.</p> </li> </ol>"},{"location":"en/user-guide/basics/#conclusion","title":"Conclusion","text":"<p>With these basic concepts, you are ready to start using CliFire in your projects. The simplicity and flexibility of this framework will allow you to build powerful and customized CLI applications without complications.</p> <p>For more details and advanced examples, consult the User Documentation and the API Reference.</p>"},{"location":"en/user-guide/classes/","title":"Class-based Commands","text":"<p>In addition to using decorators, CliFire allows you to define commands using classes. This approach is useful when you need more customization or complex logic in your commands.</p>"},{"location":"en/user-guide/classes/#defining-a-command-with-classes","title":"Defining a Command with Classes","text":"<p>To create a class-based command, inherit from <code>command.Command</code> and set the following properties:</p> <ul> <li><code>_name</code>: The name of the command. If you want to group commands, use dots (for example, <code>db.create</code>).</li> <li><code>_help</code>: A brief description that will be displayed in the help.</li> <li>Fields/Arguments: Define arguments and options as class attributes using <code>command.Field</code>.</li> </ul> <p>Basic example:</p> <pre><code>from clifire import command, out\n\nclass CommandGreet(command.Command):\n    _name = \"greet\"\n    _help = \"Greets the user in a personalized way\"\n\n    # Define a field for the name (non-option argument)\n    name = command.Field(\n        pos=1,\n        help=\"User's name\",\n        default=\"World\",\n        alias=[],\n    )\n\n    # Define a field to enable informal greeting (option)\n    informal = command.Field(\n        pos=None,\n        help=\"Use informal greeting\",\n        default=False,\n        alias=[\"-i\"],\n    )\n\n    def fire(self):\n        if self.informal:\n            out.info(f\"Hello, {self.name}! How's it going?\")\n        else:\n            out.info(f\"Good morning, {self.name}!\")\n</code></pre>"},{"location":"en/user-guide/classes/#registration-and-execution","title":"Registration and Execution","text":"<p>When the application is instantiated, the command is registered and can be executed from the command line:</p> <pre><code>$ fire greet\nGood morning, World!\n\n$ fire greet Alice -i\nHello, Alice! How's it going?\n</code></pre>"},{"location":"en/user-guide/classes/#advantages-of-the-class-based-approach","title":"Advantages of the Class-based Approach","text":"<ul> <li>Greater control and customization: You can define your own methods and attributes to handle complex use cases.</li> <li>Inheritance: You can create base commands and extend them to share common behaviors.</li> <li>Organization: Results in a clear and modular structure when you have a large number of commands.</li> </ul>"},{"location":"en/user-guide/classes/#internal-details","title":"Internal Details","text":"<p>When the application is instantiated, the commands defined as classes are registered. The application calls the <code>fire()</code> method of the corresponding command after parsing its arguments and options. Additionally:</p> <ul> <li>Fields are automatically updated based on the command parsing.</li> <li>Aliases and type conversions are managed in the <code>Field</code> class (see command.py).</li> </ul> <p>With this mechanism, you can take full advantage of Python's flexibility and create commands with advanced behaviors without complicating the function-level syntax.</p> <p>Explore and experiment by creating your own custom commands!</p>"},{"location":"en/user-guide/config/","title":"Configuration","text":"<p>The <code>Config</code> module in CliFire is responsible for managing your application's configuration through YAML files. It allows you to read and write the configuration while automatically ensuring that private fields (those whose names begin with <code>_</code>) are excluded.</p>"},{"location":"en/user-guide/config/#main-features","title":"Main Features","text":"<ul> <li> <p>Automatic Exclusion of Private Fields:   When writing the configuration, properties whose names start with <code>_</code> are excluded, ensuring that sensitive or internal information is not stored in the file.</p> </li> <li> <p>Flexible Loading of Configuration Files:   The class method <code>get_config</code> allows you to specify a list of possible configuration files. The first existing file is loaded or, if none exists, one can be created if the <code>create</code> option is enabled.</p> </li> <li> <p>Dynamic Attribute Management:   Configuration values are assigned as attributes of the <code>Config</code> instance, allowing you to access them dynamically using the <code>get</code> method.</p> </li> </ul>"},{"location":"en/user-guide/config/#usage-example","title":"Usage Example","text":"<p>You can use the <code>Config</code> module independently or within the <code>App</code> class to manage your CLI application's configuration.</p> <pre><code>from clifire import application, command, out\n\n\nclass ConfigCommand(command.Command):\n    _name = \"config\"\n    _help = \"Show config vars\"\n\n    def fire(self):\n        self.app.config.my_new_var = \"My new var\"\n        out.var_dump(self.app.config)\n\n\ndef main():\n    app = application.App(config_files=[\"~/.myapp.yml\"], config_create=True)\n    app.add_command(ConfigCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Now we can run it:</p> <p></p>"},{"location":"en/user-guide/config/#reading-the-configuration","title":"Reading the Configuration","text":"<p>To load your application's configuration, use the <code>get_config</code> method. For example:</p> <pre><code>from clifire import config\n\n# Attempt to load configuration from 'config.yaml' or 'default.yaml'\ncfg = config.Config.get_config([\"config.yaml\", \"default.yaml\"])\nif not cfg.read():\n    print(\"Configuration file not found.\")\nelse:\n    print(\"Configuration loaded successfully.\")\n    print(\"Application Name:\", cfg.get(\"name\"))\n</code></pre> <p>In this example, if the configuration file exists, the attributes of the <code>cfg</code> instance are updated. If it does not exist, <code>read()</code> returns <code>False</code>.</p>"},{"location":"en/user-guide/config/#writing-the-configuration","title":"Writing the Configuration","text":"<p>To save the current configuration to a file, use the <code>write()</code> method. Note how private fields are excluded:</p> <pre><code>from clifire import config\n\ncfg = config.Config(config_file=\"config.yaml\")\ncfg.name = \"MyApp\"\ncfg.version = \"1.0.0\"\ncfg._secret_key = \"my-secret-key\"  # This will not be saved\ncfg.write()\n</code></pre> <p>Private Field Exclusion</p> <p>All variables that begin with <code>_</code> will not be saved in the YAML file. This is useful for keeping sensitive or internal application data private.</p>"},{"location":"en/user-guide/config/#summary","title":"Summary","text":"<p>The <code>Config</code> module provides a simple and secure way to manage your CLI application's configuration using YAML files. When reading and writing configuration data, private fields are automatically excluded, which helps maintain both security and cleanliness of the stored data.</p> <p>This robust functionality facilitates centralized configuration management in CliFire, contributing to the flexibility and maintainability of your applications.</p>"},{"location":"en/user-guide/decorators/","title":"Decorators in CliFire","text":"<p>In CliFire, decorators simplify the creation and registration of commands in a clean and elegant way. With the <code>@command.fire</code> decorator, you can easily transform regular functions into CLI commands.</p>"},{"location":"en/user-guide/decorators/#what-is-a-decorator","title":"What is a Decorator?","text":"<p>In Python, a decorator is a function that receives another function and extends or modifies it without altering its structure. In the context of CliFire, the decorator:</p> <ul> <li>Registers the command in the application.</li> <li>Extracts information (name, arguments, docstring) needed for the command.</li> <li>Prepares the function to be invoked from the command line.</li> </ul>"},{"location":"en/user-guide/decorators/#using-the-commandfire-decorator","title":"Using the <code>@command.fire</code> Decorator","text":"<p>The <code>@command.fire</code> decorator is the simplest way to convert a function into a command within CliFire. For example, create the file <code>fire/greet.py</code> with the following content:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre> <p>By applying <code>@command.fire</code>:</p> <ul> <li>The <code>greet</code> function is transformed into a command object.</li> <li>Information such as the command name and its arguments is extracted from the docstring.</li> <li>The command is automatically registered to be used in the CLI.</li> </ul>"},{"location":"en/user-guide/decorators/#advantages-of-using-decorators","title":"Advantages of Using Decorators","text":"<ul> <li>Simplicity: Define commands in just a few lines of code.</li> <li>Organization: Separates command logic from CLI interface configuration.</li> <li>Flexibility: Allows you to define arguments and options using type annotations and docstring comments.</li> </ul>"},{"location":"en/user-guide/decorators/#automatic-command-registration","title":"Automatic Command Registration","text":"<p>When you define a function with <code>@command.fire</code>, the decorator performs the following operations:</p> <ol> <li>Obtains the command name using <code>func.__name__</code> or a custom attribute.</li> <li>Processes the docstring to extract the description and details for each argument.</li> <li>Dynamically creates a class that inherits from <code>command.Command</code> representing the command.</li> <li>Registers this command in the current application using <code>get_current_app().add_command(...)</code>.</li> </ol>"},{"location":"en/user-guide/decorators/#command-execution","title":"Command Execution","text":"<p>The help is automatically built from the docstring, enabling users to quickly understand how to use the command:</p> <p></p> <p>You can execute the <code>greet</code> command directly: </p>"},{"location":"en/user-guide/decorators/#the-fire-command","title":"The <code>fire</code> Command","text":"<p>The <code>fire</code> command is the main entry point for interacting with your CLI application. It allows you to execute commands and pass arguments and options.</p> <p><code>fire</code> searches for your commands either in a <code>fire.py</code> file or in the <code>fire/*.py</code> folder in the directory where it is launched.</p>"},{"location":"en/user-guide/decorators/#customization","title":"Customization","text":"<p>If you need to modify a command's behavior: - You can adjust the options and arguments in the decorator. - Use clear docstrings to define the command help. - Explore the implementation of <code>@command.fire</code> in <code>clifire/command.py</code> to see how the information is processed.</p> <p>With this decorator-based mechanism, CliFire allows you to build commands quickly while keeping your code clean and organized.</p> <p>Start using decorators to simplify the creation of your commands and take advantage of the flexibility that CliFire offers!</p>"},{"location":"en/user-guide/grouped-commands/","title":"Grouped Commands in CliFire","text":"<p>CliFire allows you to organize commands into groups using a dot-based naming convention. This is especially useful when your CLI application has many features, as it improves readability and organization.</p>"},{"location":"en/user-guide/grouped-commands/#how-it-works","title":"How It Works","text":"<p>To group commands, simply define the command name using a dot (<code>.</code>) to separate the group name from the specific command. For example, to group database-related commands, you can use names like <code>db.create</code> and <code>db.drop</code>.</p> <p>When the command is registered, CliFire's help functionality (for example, in the help command) detects the <code>.</code> character and automatically groups the commands under the same category.</p>"},{"location":"en/user-guide/grouped-commands/#example-of-defining-grouped-commands","title":"Example of Defining Grouped Commands","text":"<p>The group is determined by the <code>_name</code> variable of the <code>Command</code> class or the method name when using decorators.</p> <p>Here is an example of how to define grouped commands using classes: <pre><code>from clifire import command, out\n\nclass DbCreateCommand(command.Command):\n    _name = \"db.create\"\n    _help = \"Create the database\"\n\n    def run(self):\n        out.info(\"Database created.\")\n\nclass DbDropCommand(command.Command):\n    _name = \"db.drop\"\n    _help = \"Drop a database\"\n\n    def run(self):\n        out.info(\"Database removed.\")\n</code></pre></p>"},{"location":"en/user-guide/grouped-commands/#registration-and-execution","title":"Registration and Execution","text":"<p>Register the commands in your application:</p> <pre><code>from clifire import application\n\napp = application.App(name=\"MyApp CLI\", version=\"1.0\")\napp.add_command(DbCreateCommand)\napp.add_command(DbDropCommand)\n</code></pre> <p>Then, when running the help command:</p> <pre><code>$ fire help\n</code></pre> <p>The output will display the grouped commands, for example:</p> <pre><code>Available Commands:\n\n  db\n    create          Create the database\n    drop            Drop the database\n</code></pre>"},{"location":"en/user-guide/grouped-commands/#using-grouped-commands-with-decorators","title":"Using Grouped Commands with Decorators","text":"<p>You can use the same grouping convention with decorators to group commands. In this case, the groups are obtained from the method name by using the <code>_</code> character:</p> <pre><code>from clifire import command, out\n\n@command.fire\ndef db_create(cmd):\n    \"\"\"\n    Create the database\n    \"\"\"\n    out.info(\"Database created.\")\n\n@command.fire\ndef db_drop(cmd):\n    \"\"\"\n    Drop the database.\n    \"\"\"\n    out.info(\"Database removed.\")\n</code></pre>"},{"location":"en/user-guide/grouped-commands/#additional-tips","title":"Additional Tips","text":"<ul> <li>Name Consistency: Make sure to follow a consistent naming convention for your commands (e.g., <code>group.command</code>) so that the grouping is intuitive.</li> <li>Subgroups: If needed, you can define multiple levels of grouping by using more than one dot (e.g., <code>db.table.create</code>).</li> <li>Help Customization: You can extend the help command functionality to modify how groups are displayed if necessary.</li> </ul> <p>With this structure, you can organize your commands clearly and provide a better user experience for your CLI application.</p>"},{"location":"en/user-guide/options-arguments/","title":"Options and Arguments in CliFire","text":"<p>In CliFire, commands can receive data both as positional arguments and options. These are defined using the <code>Field</code> class in the <code>command</code> module.</p>"},{"location":"en/user-guide/options-arguments/#field-definition","title":"Field Definition","text":"<p>Each field declared as an attribute in a command is recognized as:</p> <ul> <li> <p>Positional Argument:   If the field has a defined <code>pos</code> value (for example, <code>pos=1</code>), it is treated as an argument that is expected in a certain order.   The arguments are assigned based on their position in the command line.</p> </li> <li> <p>Option:   If <code>pos</code> is <code>False</code> or <code>None</code>, the field is interpreted as an option.   Options are indicated on the command line with a single or double dash (for example, <code>-v</code> or <code>--verbose</code>).   Additionally, aliases can be defined to facilitate its usage.</p> </li> </ul>"},{"location":"en/user-guide/options-arguments/#example-of-field-definition-in-a-command","title":"Example of Field Definition in a Command","text":"<pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Example command using options and arguments\"\n\n    # Positional argument (for example, the first argument after the command name)\n    filename = command.Field(\n        pos=1,\n        help=\"Name of the file to process\",\n        default=\"default.txt\",  # default value if not specified\n    )\n\n    # Option activated with a flag (for example, -v for verbose)\n    verbose = command.Field(\n        pos=False,\n        help=\"Detailed mode\",\n        default=False,\n        alias=[\"v\"],\n    )\n\n    # Option expecting a value (for example, --level=3)\n    level = command.Field(\n        pos=False,\n        help=\"Level of detail\",\n        default=1,\n        alias=[\"l\"],\n        force_type=int,\n    )\n\n    def run(self):\n        out.info(f\"File: {self.filename}\")\n        out.info(f\"Verbose: {self.verbose}\")\n        out.info(f\"Level: {self.level}\")\n</code></pre> <p>In this example: - <code>filename</code> is a positional argument: the first value not associated with an option is assigned. - <code>verbose</code> is a boolean option: it is activated with <code>-v</code> or <code>--verbose</code>. - <code>level</code> is an option expecting a numerical value; it can be used as <code>--level=3</code> or <code>-l 3</code>.</p>"},{"location":"en/user-guide/options-arguments/#parsing-and-conversion-process","title":"Parsing and Conversion Process","text":"<p>When a command is executed: 1. Parsing:    CliFire reads the command line and separates the arguments and options using <code>shlex.split()</code>.    Positional arguments are assigned according to the order defined in the command\u2019s <code>_argument_names</code> property.</p> <ol> <li>Value Conversion:    Each field uses its <code>convert</code> method to transform the received string into its expected type.    For example:</li> <li>If the field <code>level</code> is defined with <code>force_type=int</code>, the string will be converted to an integer.</li> <li> <p>If the field is of type <code>list</code>, comma separation can be used to obtain a list of elements.</p> </li> <li> <p>Validations:</p> </li> <li>If a field is mandatory (without a default value), it is checked that a value has been provided.</li> <li>Options can have aliases; these are normalized (for example, by removing dashes and replacing <code>-</code> with <code>_</code>) to avoid duplicates.</li> </ol>"},{"location":"en/user-guide/options-arguments/#running-a-command-with-options-and-arguments","title":"Running a Command with Options and Arguments","text":"<p>When executing the above command from the terminal, you might experience different behaviors:</p> <pre><code>$ fire test myfile.txt -v --level=5\n</code></pre> <ul> <li>The value <code>\"myfile.txt\"</code> will be assigned to <code>filename</code>.</li> <li>The <code>-v</code> option sets <code>verbose</code> to <code>True</code>.</li> <li>The argument <code>--level=5</code> will be converted to an integer (<code>5</code>) and assigned to <code>level</code>.</li> </ul> <p>If some values are not provided, the default values defined will be used.</p>"},{"location":"en/user-guide/options-arguments/#conclusion","title":"Conclusion","text":"<p>Thanks to this flexible structure, CliFire makes it easy to define how data is received and processed in your commands. You can combine positional arguments and options with aliases, validations, and automatic type conversion, which simplifies the construction of robust and easy-to-use command line interfaces.</p> <p>Experiment by creating your own commands and adjusting the options according to your application\u2019s needs!</p>"},{"location":"en/user-guide/output/","title":"The <code>out</code> Module: Output and Styling","text":"<p>The <code>out</code> module in CliFire simplifies printing messages to the terminal in various styles and colors by harnessing the power of the Rich library. With these functions, you can display information, warnings, errors, success messages, debug outputs, and even live updates.</p>"},{"location":"en/user-guide/output/#main-functions","title":"Main Functions","text":"<p>Import the <code>out</code> module into your application as follows:</p> <pre><code>from clifire import out\n</code></pre> <p>Below are the most commonly used functions:</p> <ul> <li> <p><code>out.info(text: str) -&gt; None</code>   Displays an informational message.   <pre><code>out.info(\"This is an informational message\")\n</code></pre></p> </li> <li> <p><code>out.success(text: str) -&gt; None</code>   Displays a success message, perfect for indicating that an operation completed successfully.   <pre><code>out.success(\"Operation completed successfully\")\n</code></pre></p> </li> <li> <p><code>out.warn(text: str) -&gt; None</code>   Prints a warning message, useful when caution is required during execution.   <pre><code>out.warn(\"Warning: check your configuration\")\n</code></pre></p> </li> <li> <p><code>out.error(text: str) -&gt; None</code>   Displays an error message prominently to signal critical failures in the process.   <pre><code>out.error(\"Critical error occurred\")\n</code></pre></p> </li> <li> <p><code>out.debug(text: str) -&gt; None</code>   Prints debug messages, which are useful during development to trace internal behavior.   <pre><code>out.debug(\"Debug: variable x = 42\")\n</code></pre></p> </li> <li> <p><code>out.var_dump(var) -&gt; None</code>   Prints the contents of a variable in a human-readable format, highlighting its structure to aid in inspection.   <pre><code>sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\nout.var_dump(sample_dict)\n</code></pre></p> </li> <li> <p><code>out.LiveText</code>   This is a class that allows you to update text in real time in the terminal. It is useful for displaying progress bars or counters that update dynamically.   <pre><code>live_text = out.LiveText(\"Starting...\")\nlive_text.info(\"Process running\")\nlive_text.warn(\"Retrying operation\")\nlive_text.success(\"Operation completed\", end=False)\n</code></pre></p> </li> </ul>"},{"location":"en/user-guide/output/#general-usage","title":"General Usage","text":"<p>The <code>out</code> module is designed to integrate seamlessly with your commands and applications built with CliFire, providing a standardized and stylized output format for the terminal. Each function applies predefined styles to ensure a consistent and appealing user experience.</p> <p>Below is a complete example:</p> <pre><code>import time\n\nfrom clifire import application, command, out\n\n\nclass OutCommand(command.Command):\n    _name = 'out'\n\n    def fire(self):\n        print('Text colors')\n        print('-' * 80)\n        out.info(\"This is an informational message\")\n        out.success(\"Operation completed successfully\")\n        out.warn(\"Warning: check your configuration\")\n        out.error(\"Critical error occurred\")\n\n        print('')\n        print('Debug')\n        print('-' * 80)\n        out.debug(\"Debug: variable x = 42\")\n        sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\n        out.var_dump(sample_dict)\n\n        print('')\n        print('Tables')\n        print('-' * 80)\n        data = [\n            {\"name\": \"Luke\", \"age\": 18, \"is_student\": True},\n            {\"name\": \"Elizabeth\", \"age\": 101, \"is_student\": False},\n        ]\n        out.table(data, border=True, title=\"Contacts\")\n\n        print('')\n        print('Live text')\n        print('-' * 80)\n        live_text = out.LiveText(\"Starting...\")\n        time.sleep(1)\n        live_text.info(\"Process running\")\n        time.sleep(1)\n        live_text.warn(\"Retrying operation\")\n        time.sleep(1)\n        live_text.success(\"Operation completed\", end=False)\n        time.sleep(1)\n\n\ndef main():\n    app = application.App()\n    app.add_command(OutCommand)\n    app.fire(\"out -v\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p>"},{"location":"en/user-guide/output/#customization","title":"Customization","text":"<p>The <code>out</code> module uses a Rich Console object (<code>out.CONSOLE</code>) which can be customized. If you need to change the styles or modify the visual behavior, you can configure this object or refer to the Rich documentation for more options.</p> <p>With this guide, you will have an overview of how to use the <code>out</code> module to enhance the presentation of messages in your CLI applications built with CliFire.</p>"},{"location":"en/user-guide/templates/","title":"Templates in CliFire","text":"<p>The <code>Template</code> module in CliFire allows you to render and save files using templates based on Jinja2. This functionality helps you generate dynamic content easily, making it ideal for creating configuration files, reports, or other documents that require customization.</p> <p>You can use the <code>Template</code> module independently, or you can use it within the <code>App</code> class to manage your CLI application's configuration.</p> <p>The file <code>sample_template/hello.jinja2</code> is an example of a template that can be used with the <code>Template</code> module. Here is an example of what the template content might look like:</p> <pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;ul&gt;\n    {% for number in numbers %}\n        &lt;li&gt;{{ number }}&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n</code></pre> <p>The CLI command will be called <code>app_template.py</code> and will look like this: <pre><code>from clifire import application, command, out\n\n\nclass HelloCommand(command.Command):\n    _name = \"hello\"\n    _help = \"Create template\"\n\n    title = command.Field(\n        pos=1,\n        force_type=str,\n    )\n\n    def fire(self):\n        print(self.title)\n        content = self.app.template.render(\n            'hello.jinja2', title=self.title, numbers=[1, 2, 3])\n        out.success(content)\n\n\ndef main():\n    app = application.App(template_folder=\"./sample_template\")\n    app.add_command(HelloCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Running this command will render the <code>hello.jinja2</code> template with the given title and a list of numbers, displaying the result in the terminal.</p> <p></p>"},{"location":"en/user-guide/templates/#main-functions","title":"Main Functions","text":"<ul> <li><code>Template.render(template: str, **args) -&gt; str</code>   Renders a specified template. It receives the template file name and additional parameters that will be used to substitute the variables defined in the template.</li> </ul> <p>Example:   <pre><code>from clifire import template\n\n# Create the Template object by specifying the folder where the templates are located.\ntpl = template.Template(\"templates\")\ncontent = tpl.render(\"sample.jinja2\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n\n# 'content' will contain the HTML generated with the provided values.\nprint(content)\n</code></pre></p> <ul> <li><code>Template.write(template: str, filename: str, mark: Optional[str] = None, **args) -&gt; str</code>   Renders the template and saves its content to a file.   If a <code>mark</code> parameter is specified, the rendered content will be inserted or replaced between special markers in the file; this is useful for updating specific sections without overwriting the rest of the content.</li> </ul> <p>Example without a marker:   <pre><code>tpl = template.Template(\"templates\")\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p> <p>Example with a marker:   <pre><code>tpl = template.Template(\"templates\")\n# The marker '&lt;&lt;CONTENT&gt;&gt;' will delimit the section to update.\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p>"},{"location":"en/user-guide/templates/#how-it-works","title":"How It Works","text":"<ol> <li> <p>Template Rendering:    The <code>render</code> method loads the template file using Jinja2 and processes it with the provided arguments. This allows you to generate dynamic content based on variables defined in your template.</p> </li> <li> <p>Saving and Updating Files:    With the <code>write</code> method, you can directly save the rendered content to a file.    If you specify a <code>mark</code>:</p> </li> <li>The method searches within the file for the section delimited by that marker.</li> <li>If it finds the section, it replaces it with the new rendered content.</li> <li> <p>If it does not exist, it appends the section at the end of the file.    This enables you to update specific parts of the file without losing the original content that lies outside of the markers.</p> </li> <li> <p>Dynamic Integration:    The <code>Template</code> object integrates with the rest of CliFire, allowing you to utilize environment variables or any other business logic during rendering.</p> </li> </ol>"},{"location":"en/user-guide/templates/#complete-example","title":"Complete Example","text":"<pre><code>from clifire import template\n\ndef generate_report():\n    # Initialize the template by specifying the template folder\n    tpl = template.Template(\"templates\")\n\n    # Render the sample.jinja2 template with dynamic data\n    content = tpl.render(\"sample.jinja2\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n    print(\"Rendered Content:\")\n    print(content)\n\n    # Save the rendered content to output.html without using markers\n    tpl.write(\"sample.jinja2\", \"output.html\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\n    # Save the content to output_marked.html using a marker to update only a section\n    tpl.write(\"sample.jinja2\", \"output_marked.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\nif __name__ == \"__main__\":\n    generate_report()\n</code></pre>"},{"location":"en/user-guide/templates/#conclusion","title":"Conclusion","text":"<p>The <code>Template</code> module allows you to separate content logic from presentation, making it easier to generate dynamic files from templates. This improves the maintainability and flexibility of your CLI applications, as you can update specific sections of a file without affecting the rest of the content.</p> <p>This functionality is especially useful for projects that require periodic creation or updating of reports, configuration files, or any other type of document based on templates.</p>"},{"location":"es/","title":"CliFire","text":"<p>Minimal CLI framework to build Python commands quickly and elegantly.</p> <p>CliFire es una biblioteca ligera dise\u00f1ada para simplificar la creaci\u00f3n de interfaces de l\u00ednea de comandos (CLI). Permite a los desarrolladores definir comandos, opciones y argumentos de manera sencilla, facilitando la construcci\u00f3n de aplicaciones CLI complejas sin la sobrecarga de frameworks m\u00e1s grandes.</p> <p>La idea de CliFire es que puedas crear CLI (Command Line Interface) de forma r\u00e1pida y sencilla, aprovechando las caracter\u00edsticas de Python. Su enfoque minimalista y su sintaxis intuitiva hacen que sea f\u00e1cil de aprender y usar, permitiendo a los desarrolladores centrarse en la l\u00f3gica de sus aplicaciones en lugar de en la infraestructura de la CLI.</p> <p>Adem\u00e1s con el comando <code>fire</code> se pueden crear comandos din\u00e1micos directamente desde la terminal, lo que permite una experiencia interactiva y flexible.</p>"},{"location":"es/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Dos estilos de uso: decoradores para un enfoque simple o clases para mayor personalizaci\u00f3n</li> <li>Sintaxis intuitiva: enfocada en la simplicidad y legibilidad</li> <li>Opciones globales y por comando: configuraci\u00f3n flexible de par\u00e1metros</li> <li>Comandos agrupados: organiza comandos relacionados jer\u00e1rquicamente</li> <li>Salidas con formato: utiliza Rich para mostrar mensajes con colores y estilos</li> <li>Plantillas integradas: crea archivos con Jinja2</li> <li>Configuraci\u00f3n centralizada: gestiona la configuraci\u00f3n de tu aplicaci\u00f3n f\u00e1cilmente</li> </ul>"},{"location":"es/#instalacion-rapida","title":"Instalaci\u00f3n r\u00e1pida","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"es/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"es/changelog/#011-2025-06-07","title":"[0.1.1] - 2025-06-07","text":""},{"location":"es/changelog/#added","title":"Added","text":"<ul> <li>Bash command <code>clifire</code>  for creating dynamic commands.</li> <li>In application module, added:</li> <li>Global option <code>--verbose</code> created by default.</li> <li>If no command is passed, help is shown if the help command is defined.</li> <li>New <code>path</code> method for get absolute path to a filename.</li> <li>New <code>config</code> variable for managing configuration settings.</li> <li>New <code>template</code> variable for creating files with jinja2.</li> <li>In out module, added:</li> <li><code>debug</code> method for printing debug messages.</li> <li><code>debug2</code> method for printing debug messages level 2.</li> <li><code>var_dump</code> method for printing pretty variables in out module.</li> <li>New <code>Config</code> class to manage configuration settings.</li> <li>New <code>Template</code> class for creating files with jinja2.</li> <li>Changed relative imports to module imports for better compatibility.</li> </ul>"},{"location":"es/changelog/#changed","title":"Changed","text":"<ul> <li>Commands now use <code>fire()</code> method instead of <code>run()</code>.</li> <li>Compatibility with Python 3.10.</li> <li>Updated documentation to include usage examples for the new <code>clifire</code> command.</li> <li>Enhanced the <code>--verbose</code> option to provide more detailed output during command execution.</li> <li>Improved Result class, stdout and stderr are now str instead of list</li> </ul>"},{"location":"es/changelog/#fixed","title":"Fixed","text":"<ul> <li>The arguments between quotes are now correctly parsed, allowing for spaces in arguments.</li> <li>The [options] message in <code>help</code> command not correctly displayed.</li> </ul>"},{"location":"es/changelog/#removed","title":"Removed","text":""},{"location":"es/changelog/#010-2025-06-01","title":"[0.1.0] - 2025-06-01","text":""},{"location":"es/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release with the first usable version.</li> </ul>"},{"location":"es/contributing/","title":"Contribuir a CliFire","text":"<p>\u00a1Gracias por tu inter\u00e9s en contribuir a CliFire!</p> <p>Las contribuciones son bienvenidas y ayudan a mejorar este proyecto minimalista para construir aplicaciones CLI en Python.</p>"},{"location":"es/contributing/#como-contribuir","title":"\u00bfC\u00f3mo Contribuir?","text":"<p>Existen varias maneras de ayudar:</p> <ul> <li>Reportando errores: Si encuentras un bug o comportamiento inesperado, por favor abre un issue en GitHub con una descripci\u00f3n detallada y, si es posible, pasos para reproducirlo.</li> <li>Solicitando nuevas funcionalidades: Si tienes una idea para mejorar CliFire, abre un issue o propone un pull request.</li> <li>C\u00f3digo y mejoras: Si deseas enviar c\u00f3digo, aseg\u00farate de seguir las pautas de estilo y a\u00f1ade pruebas unitarias para respaldar tus cambios.</li> <li>Documentaci\u00f3n: Ayuda a mejorar la documentaci\u00f3n, ya sea corrigiendo errores, ampliando secciones o a\u00f1adiendo ejemplos de uso.</li> </ul>"},{"location":"es/contributing/#flujo-de-contribucion","title":"Flujo de Contribuci\u00f3n","text":""},{"location":"es/contributing/#fork-del-repositorio","title":"Fork del repositorio","text":"<p>Haz un fork del proyecto en GitHub.</p>"},{"location":"es/contributing/#clona-tu-fork-en-local","title":"Clona tu fork en local:","text":"<pre><code>git clone https://github.com/your-user/clifire.git\ncd clifire\n</code></pre>"},{"location":"es/contributing/#crea-una-rama-para-tus-cambios","title":"Crea una rama para tus cambios:","text":"<pre><code>git checkout -b my-changes\n</code></pre>"},{"location":"es/contributing/#realiza-tus-cambios","title":"Realiza tus cambios:","text":"<p>Realiza los cambios necesarios en el c\u00f3digo. Aseg\u00farate de que:</p> <ul> <li>Sigue las convenciones de estilo del proyecto.</li> <li>A\u00f1ade pruebas unitarias, el proyecto tiene el 100% de coverage!.</li> <li>Actualiza o a\u00f1ade documentaci\u00f3n si fuera necesario.</li> </ul>"},{"location":"es/contributing/#ejecuta-los-tests","title":"Ejecuta los tests:","text":"<p>Aseg\u00farate de que todos los tests pasan con:    <pre><code>poetry run pytest\n</code></pre>    Comprueba la cobertura:    <pre><code>poetry run coverage run -m pytest &amp;&amp; poetry run coverage html\n</code></pre></p> <p>Tambi\u00e9n puedes usar <code>poetry run fire coverage</code> para ejecutar los tests y generar el informe de cobertura.</p>"},{"location":"es/contributing/#realiza-un-pull-request","title":"Realiza un Pull Request:","text":"<p>Una vez que est\u00e9s satisfecho con tus cambios, realiza un pull request a la rama principal del repositorio. Describe detalladamente lo que has cambiado y la motivaci\u00f3n detr\u00e1s de ello.</p>"},{"location":"es/contributing/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ul> <li>Escribe mensajes de commit claros y descriptivos.</li> <li>Sigue el formato de Keep a Changelog para documentar tus cambios.</li> <li>Aseg\u00farate de que las nuevas funcionalidades o arreglos no rompan la compatibilidad existente.</li> <li>Respeta el formato y la estructura de la documentaci\u00f3n existente.</li> </ul>"},{"location":"es/contributing/#revision-y-feedback","title":"Revisi\u00f3n y Feedback","text":"<p>Tu pull request ser\u00e1 revisado por mantenedores del proyecto. Es posible que te pidan ajustes o aclaraciones, \u00a1as\u00ed que estate atento a los comentarios!</p> <p>Para m\u00e1s detalles, consulta la Gu\u00eda de Contribuci\u00f3n Completa en el repositorio.</p> <p>\u00a1Gracias por ayudar a que CliFire crezca y mejore!</p>"},{"location":"es/quick-start/","title":"Gu\u00eda R\u00e1pida - Empezando con CliFire","text":"<p>Bienvenido a la gu\u00eda r\u00e1pida de CliFire, un framework minimalista para crear interfaces de l\u00ednea de comandos en Python de forma sencilla y elegante.</p>"},{"location":"es/quick-start/#instalacion","title":"Instalaci\u00f3n","text":"<p>Puedes instalar CliFire desde PyPI o directamente usando Poetry:</p>"},{"location":"es/quick-start/#desde-pypi","title":"Desde PyPI","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"es/quick-start/#usando-poetry","title":"Usando Poetry","text":"<pre><code>poetry add clifire\n</code></pre>"},{"location":"es/quick-start/#uso-basico","title":"Uso B\u00e1sico","text":"<p>CliFire te permite definir comandos mediante decoradores o clases. Aqu\u00ed tienes un ejemplo utilizando un decorador para saludar al usuario:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre>"},{"location":"es/quick-start/#ejecutando-el-comando","title":"Ejecutando el Comando","text":"<p>Guarda el archivo como <code>fire.py</code> o crea un directorio <code>fire</code> y coloca el archivo dentro con extensi\u00f3n <code>.py</code>.</p> <p>La ayuda se construye autom\u00e1ticamente a partir del docstring, lo que permite a los usuarios entender r\u00e1pidamente c\u00f3mo usar el comando:</p> <p></p> <p>Puedes ejecutar el comando <code>greet</code> directamente: </p>"},{"location":"es/quick-start/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Definici\u00f3n Sencilla de Comandos: Usa decoradores o clases para crear comandos din\u00e1micos.</li> <li>Manejo de Argumentos y Opciones: Define argumentos y opciones para personalizar el comportamiento de tus comandos.</li> <li>Salida formateada: Utiliza el m\u00f3dulo <code>out</code> para mostrar mensajes con estilos y colores usando la libreria <code>Rich</code>.</li> <li>Configuraci\u00f3n centralizada: Administra la configuraci\u00f3n de tu aplicaci\u00f3n mediante la clase <code>Config</code>.</li> <li>Plantillas de ficheros: Crea archivos con plantillas Jinja2 usando la clase <code>Template</code>.</li> </ul>"},{"location":"es/quick-start/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Para m\u00e1s detalles sobre la API y configuraci\u00f3n, consulta la Documentaci\u00f3n de Usuario.</li> <li>Revisa la API Reference para ver todas las funciones y clases disponibles.</li> <li>Mira ejemplos pr\u00e1cticos en la secci\u00f3n Ejemplos.</li> </ul> <p>\u00a1Empieza a crear tus comandos y disfruta de una experiencia minimalista y potente con CliFire!</p>"},{"location":"es/user-guide/basics/","title":"Conceptos B\u00e1sicos de CliFire","text":"<p>CliFire es un framework minimalista para crear aplicaciones de l\u00ednea de comandos en Python de forma sencilla y elegante. Esta gu\u00eda te introduce en los conceptos fundamentales para que puedas empezar a utilizarlo r\u00e1pidamente.</p> <p>Tenemos dos sabores para usar CliFire, por decoradores o por clases:</p> <ul> <li>Decoradores: Permiten definir comandos de forma r\u00e1pida y sencilla, sin perder potencia ni flexibilidad.</li> <li>Clases: Ofrecen un control m\u00e1s detallado sobre el comportamiento de los comandos, ideal para aplicaciones m\u00e1s complejas.</li> </ul> <p>La idea de CliFire es que puedas crear aplicaciones CLI (Command Line Interface) de forma r\u00e1pida y sencilla, aprovechando las caracter\u00edsticas de Python.</p>"},{"location":"es/user-guide/basics/#1-comandos","title":"1. Comandos","text":"<p>Los comandos son la esencia de tu aplicaci\u00f3n CLI. Puedes definirlos de dos formas:</p> <ul> <li>Usando decoradores:   Se facilita la creaci\u00f3n de comandos con el decorador <code>@command.fire</code>.</li> </ul> <pre><code>from clifire import command, out\n\n@command.fire\ndef hello(cmd, name: str = \"World\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user. Defaults to \"World\".\n    \"\"\"\n    out.info(f\"Hello, {name}!\")\n</code></pre> <ul> <li>Usando clases:   Crear una clase que herede de <code>command.Command</code> para tener mayor control sobre el comportamiento del comando.</li> </ul> <pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    def fire(self):\n        out.info(\"Executing test command\")\n</code></pre>"},{"location":"es/user-guide/basics/#2-opciones-y-argumentos","title":"2. Opciones y Argumentos","text":"<p>CliFire te permite definir:</p> <ul> <li>Opciones Globales: Configuraciones que afectan a toda la aplicaci\u00f3n (por ejemplo, el modo verbose).</li> <li>Opciones Locales: Argumentos y opciones espec\u00edficos para cada comando.</li> </ul> <p>Estas opciones se pueden establecer con la clase <code>Field</code> del m\u00f3dulo <code>command</code>.</p> <pre><code>from clifire import command\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    bool_option = command.Field(\n        pos=1,\n        help=\"Example boolean option\",\n        default=False,\n        alias=[\"-v\"],\n    )\n\n    def fire(self):\n        if self.bool_option:\n            print(\"Verbose option enabled\")\n        else:\n            print(\"Verbose option disabled\")\n</code></pre>"},{"location":"es/user-guide/basics/#3-configuracion","title":"3. Configuraci\u00f3n","text":"<p>La clase <code>Config</code> gestiona la configuraci\u00f3n de tu aplicaci\u00f3n. Permite leer datos de ficheros YAML y escribirlos, excluyendo campos privados (aquellos que comienzan con <code>_</code>).</p> <pre><code>from clifire import config\n\nconf = config.Config(config_file=\"config.yaml\")\nconf.name = \"MyApp\"\nconf.version = \"1.0.0\"\nconf.write()\n</code></pre> <p>Nota: Los campos privados (por ejemplo, <code>_secret</code>) no se guardan en el fichero de configuraci\u00f3n.</p>"},{"location":"es/user-guide/basics/#4-salida-y-estilos","title":"4. Salida y Estilos","text":"<p>El m\u00f3dulo <code>out</code> utiliza la biblioteca Rich para mostrar mensajes con distintos estilos y colores:</p> <ul> <li><code>out.info()</code>: Informaci\u00f3n.</li> <li><code>out.success()</code>: \u00c9xito.</li> <li><code>out.warn()</code>: Advertencia.</li> <li><code>out.error()</code>: Error.</li> </ul> <pre><code>from clifire import out\n\nout.info(\"This is an informational message\")\n</code></pre>"},{"location":"es/user-guide/basics/#5-plantillas","title":"5. Plantillas","text":"<p>La clase <code>Template</code> te permite generar archivos a partir de plantillas Jinja2. Esto es \u00fatil para crear ficheros con contenido din\u00e1mico de forma sencilla.</p> <pre><code>from clifire import template\n\ntpl = template.Template(template_folder=\"templates\")\ncontent = tpl.render(\n    \"sample.jinja2\",\n    title=\"My Title\",\n    user=\"admin\",\n    items=[\"data1\", \"data2\"]\n)\n</code></pre> <p>Adem\u00e1s, la funci\u00f3n <code>write</code> de la plantilla permite guardar el contenido renderizado en un fichero, con la opci\u00f3n de insertar o reemplazar contenido delimitado por marcas.</p> <p>Esto es \u00fatil para generar archivos de configuraci\u00f3n o scripts personalizados que se pueden actualizar f\u00e1cilmente en el futuro sin afectar al resto del contenido del archivo.</p>"},{"location":"es/user-guide/basics/#6-flujo-de-ejecucion","title":"6. Flujo de Ejecuci\u00f3n","text":"<ol> <li> <p>Definici\u00f3n de Comandos:    Se definen mediante decoradores o clases.</p> </li> <li> <p>Registro de Comandos:    Al instanciar <code>App</code> se registran los comandos. Por defecto, se a\u00f1ade un comando de ayuda que muestra la informaci\u00f3n de todos los comandos disponibles.</p> </li> <li> <p>Parseo y Ejecuci\u00f3n:    Al lanzar la aplicaci\u00f3n se analiza la l\u00ednea de comandos, se identifica el comando a ejecutar y se procesan sus opciones y argumentos.</p> </li> </ol>"},{"location":"es/user-guide/basics/#conclusion","title":"Conclusi\u00f3n","text":"<p>Con estos conceptos b\u00e1sicos, ya est\u00e1s listo para empezar a usar CliFire en tus proyectos. La simplicidad y flexibilidad de este framework te permitir\u00e1n construir aplicaciones CLI potentes y personalizadas sin complicaciones.</p> <p>Para m\u00e1s detalles y ejemplos avanzados revisa la Gu\u00eda de Usuario y la API Reference.</p>"},{"location":"es/user-guide/classes/","title":"Comandos Basados en Clases","text":"<p>Adem\u00e1s de usar decoradores, CliFire permite definir comandos mediante clases. Este enfoque es \u00fatil cuando necesitas mayor personalizaci\u00f3n o l\u00f3gica compleja en tus comandos.</p>"},{"location":"es/user-guide/classes/#definiendo-un-comando-con-clases","title":"Definiendo un Comando con Clases","text":"<p>Para crear un comando basado en clases, hereda de <code>command.Command</code> y establece las siguientes propiedades:</p> <ul> <li><code>_name</code>: Nombre del comando. Si deseas agrupar comandos, usa puntos (por ejemplo, <code>db.create</code>).</li> <li><code>_help</code>: Descripci\u00f3n breve que se mostrar\u00e1 en la ayuda.</li> <li>Campos/Argumentos: Define los argumentos y opciones como atributos de la clase utilizando <code>command.Field</code>.</li> </ul> <p>Ejemplo b\u00e1sico:</p> <pre><code>from clifire import command, out\n\nclass CommandGreet(command.Command):\n    _name = \"greet\"\n    _help = \"Greets the user in a personalized way\"\n\n    # Define a field for the name (non-option argument)\n    name = command.Field(\n        pos=1,\n        help=\"User's name\",\n        default=\"World\",\n        alias=[],\n    )\n\n    # Define a field to enable informal greeting (option)\n    informal = command.Field(\n        pos=None,\n        help=\"Use informal greeting\",\n        default=False,\n        alias=[\"-i\"],\n    )\n\n    def fire(self):\n        if self.informal:\n            out.info(f\"Hello, {self.name}! How's it going?\")\n        else:\n            out.info(f\"Good morning, {self.name}!\")\n</code></pre>"},{"location":"es/user-guide/classes/#registro-y-ejecucion","title":"Registro y Ejecuci\u00f3n","text":"<p>Al instanciar la aplicaci\u00f3n, el comando se registra y se puede ejecutar desde la l\u00ednea de comandos:</p> <pre><code>$ fire greet\nGood morning, World!\n\n$ fire greet Alice -i\nHello, Alice! How's it going?\n</code></pre>"},{"location":"es/user-guide/classes/#ventajas-del-enfoque-basado-en-clases","title":"Ventajas del Enfoque basado en Clases","text":"<ul> <li>Mayor control y personalizaci\u00f3n: Puedes definir m\u00e9todos y atributos propios para manejar casos de uso complejos.</li> <li>Herencia: Puedes crear comandos base y extenderlos para compartir comportamientos comunes.</li> <li>Organizaci\u00f3n: Resultado en una estructura clara y modular cuando se tiene una gran cantidad de comandos.</li> </ul>"},{"location":"es/user-guide/classes/#detalles-internos","title":"Detalles Internos","text":"<p>Cuando se instancia la aplicaci\u00f3n, se registran los comandos definidos como clases. La aplicaci\u00f3n llama al m\u00e9todo <code>fire()</code> del comando correspondiente, luego de haber parseado los argumentos y opciones. Adem\u00e1s:</p> <ul> <li>Los campos se actualizan autom\u00e1ticamente desde el parseo del comando.</li> <li>Los alias y conversiones de tipos se gestionan en la clase <code>Field</code> (ver command.py).</li> </ul> <p>Con este mecanismo, puedes aprovechar al m\u00e1ximo la flexibilidad de Python y crear comandos con comportamientos avanzados sin complicar la sintaxis a nivel de funci\u00f3n.</p> <p>\u00a1Explora y experimenta creando tus propios comandos personalizados!</p>"},{"location":"es/user-guide/config/","title":"Configuration (Configuraci\u00f3n)","text":"<p>El m\u00f3dulo <code>Config</code> de CliFire se encarga de gestionar la configuraci\u00f3n de la aplicaci\u00f3n a trav\u00e9s de archivos YAML. Permite leer y escribir la configuraci\u00f3n, asegur\u00e1ndose de excluir autom\u00e1ticamente los campos privados (aquellos cuyo nombre comienza con <code>_</code>).</p>"},{"location":"es/user-guide/config/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li> <p>Exclusi\u00f3n autom\u00e1tica de campos privados:   Cuando se escribe la configuraci\u00f3n, se excluyen las propiedades cuyo nombre inicia con <code>_</code>, asegurando que la informaci\u00f3n sensible o interna no se almacene en el archivo.</p> </li> <li> <p>Carga flexible de archivos de configuraci\u00f3n:   El m\u00e9todo de clase <code>get_config</code> permite especificar una lista de posibles archivos de configuraci\u00f3n. Se carga el primer archivo existente o, si ninguno existe, se puede crear uno si se indica con la opci\u00f3n <code>create</code>.</p> </li> <li> <p>Gesti\u00f3n din\u00e1mica de atributos:   Los valores de configuraci\u00f3n se asignan como atributos de la instancia de <code>Config</code>, permitiendo acceder a ellos de forma din\u00e1mica mediante el m\u00e9todo <code>get</code>.</p> </li> </ul>"},{"location":"es/user-guide/config/#ejemplo-de-uso","title":"Ejemplo de Uso","text":"<p>Puede usar el m\u00f3dulo <code>Config</code> de manera independiente, o puede usarlo dentro de la clase <code>App</code> para manejar la configuraci\u00f3n de su aplicaci\u00f3n CLI.</p> <pre><code>from clifire import application, command, out\n\n\nclass ConfigCommand(command.Command):\n    _name = \"config\"\n    _help = \"Show config vars\"\n\n    def fire(self):\n        self.app.config.my_new_var = \"My new var\"\n        out.var_dump(self.app.config)\n\n\ndef main():\n    app = application.App(config_files=[\"~/.myapp.yml\"], config_create=True)\n    app.add_command(ConfigCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Ahora podemos ejecutarlo</p> <p></p>"},{"location":"es/user-guide/config/#leer-la-configuracion","title":"Leer la Configuraci\u00f3n","text":"<p>Para cargar la configuraci\u00f3n de la aplicaci\u00f3n, utiliza el m\u00e9todo <code>get_config</code>. Por ejemplo:</p> <pre><code>from clifire import config\n\n# Attempt to load configuration from 'config.yaml' or 'default.yaml'\ncfg = config.Config.get_config([\"config.yaml\", \"default.yaml\"])\nif not cfg.read():\n    print(\"Configuration file not found.\")\nelse:\n    print(\"Configuration loaded successfully.\")\n    print(\"Application Name:\", cfg.get(\"name\"))\n</code></pre> <p>En este ejemplo, si el archivo de configuraci\u00f3n existe, se actualizan los atributos de la instancia <code>cfg</code>. Si no, <code>read()</code> retorna <code>False</code>.</p>"},{"location":"es/user-guide/config/#escribir-la-configuracion","title":"Escribir la Configuraci\u00f3n","text":"<p>Para guardar la configuraci\u00f3n actual en un archivo, utiliza el m\u00e9todo <code>write()</code>. Observa c\u00f3mo se excluyen los campos privados:</p> <pre><code>from clifire import config\n\ncfg = config.Config(config_file=\"config.yaml\")\ncfg.name = \"MyApp\"\ncfg.version = \"1.0.0\"\ncfg._secret_key = \"my-secret-key\"  # This will not be saved\ncfg.write()\n</code></pre> <p>Exclusi\u00f3n de Campos Privados</p> <p>Todas las variables que comienzan con <code>_</code> no se guardar\u00e1n en el archivo YAML. Esto es \u00fatil para mantener la privacidad de los datos sensibles o internos de la aplicaci\u00f3n.</p>"},{"location":"es/user-guide/config/#resumen","title":"Resumen","text":"<p>El m\u00f3dulo <code>Config</code> proporciona una forma sencilla y segura de administrar la configuraci\u00f3n de tu aplicaci\u00f3n CLI mediante archivos YAML. Al leer y escribir la configuraci\u00f3n, se excluyen autom\u00e1ticamente los campos privados, lo que ayuda a mantener la seguridad y la limpieza de los datos almacenados.</p> <p>Esta funcionalidad robusta facilita la centralizaci\u00f3n y el manejo de la configuraci\u00f3n en CliFire, contribuyendo a la flexibilidad y mantenibilidad de tus aplicaciones.</p>"},{"location":"es/user-guide/decorators/","title":"Decoradores en CliFire","text":"<p>En CliFire, los decorators facilitan la creaci\u00f3n y registro de comandos de manera simple y elegante. Gracias al decorador <code>@command.fire</code> puedes transformar f\u00e1cilmente funciones regulares en comandos CLI.</p>"},{"location":"es/user-guide/decorators/#que-es-un-decorator","title":"\u00bfQu\u00e9 es un Decorator?","text":"<p>En Python, un decorator es una funci\u00f3n que recibe otra funci\u00f3n y la extiende o modifica sin alterar su estructura. En el contexto de CliFire, el decorador:</p> <ul> <li>Registra el comando en la aplicaci\u00f3n.</li> <li>Extrae informaci\u00f3n (nombre, argumentos, docstring) necesaria para el comando.</li> <li>Prepara la funci\u00f3n para invocarse desde la l\u00ednea de comandos.</li> </ul>"},{"location":"es/user-guide/decorators/#uso-del-decorador-commandfire","title":"Uso del Decorador <code>@command.fire</code>","text":"<p>El decorador <code>@command.fire</code> es la forma m\u00e1s sencilla de convertir una funci\u00f3n en un comando dentro de CliFire. Por ejemplo, creamos el fichero <code>fire/greet.py</code> con el siguiente contenido:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre> <p>Al aplicar <code>@command.fire</code>:</p> <ul> <li>La funci\u00f3n <code>greet</code> se transforma en un objeto comando.</li> <li>Se extrae la informaci\u00f3n del nombre del comando y de los argumentos a partir del docstring.</li> <li>El comando queda registrado autom\u00e1ticamente para ser utilizado en la CLI.</li> </ul>"},{"location":"es/user-guide/decorators/#ventajas-de-usar-decorators","title":"Ventajas de Usar Decorators","text":"<ul> <li>Simplicidad: Define comandos con pocas l\u00edneas de c\u00f3digo.</li> <li>Organizaci\u00f3n: Separa la l\u00f3gica del comando de la configuraci\u00f3n de la interfaz CLI.</li> <li>Flexibilidad: Permite definir argumentos y opciones mediante anotaciones de tipos y comentarios en el docstring.</li> </ul>"},{"location":"es/user-guide/decorators/#registro-automatico-del-comando","title":"Registro Autom\u00e1tico del Comando","text":"<p>Cuando defines una funci\u00f3n con <code>@command.fire</code>, el decorador realiza las siguientes operaciones:</p> <ol> <li>Obtiene el nombre del comando utilizando <code>func.__name__</code> o un atributo personalizado.</li> <li>Procesa el docstring para extraer la descripci\u00f3n y detalles de cada argumento.</li> <li>Crea din\u00e1micamente una clase que hereda de <code>command.Command</code> y que representa el comando.</li> <li>Registra este comando en la aplicaci\u00f3n actual mediante <code>get_current_app().add_command(...)</code>.</li> </ol>"},{"location":"es/user-guide/decorators/#ejecucion-de-comandos","title":"Ejecuci\u00f3n de Comandos","text":"<p>La ayuda se construye autom\u00e1ticamente a partir del docstring, lo que permite a los usuarios entender r\u00e1pidamente c\u00f3mo usar el comando:</p> <p></p> <p>Puedes ejecutar el comando <code>greet</code> directamente: </p>"},{"location":"es/user-guide/decorators/#el-comando-fire","title":"El comando <code>fire</code>","text":"<p>El comando <code>fire</code> es la entrada principal para interactuar con tu aplicaci\u00f3n CLI. Permite ejecutar comandos y pasarles argumentos y opciones.</p> <p><code>fire</code> busca tus comandos o en un fichero <code>fire.py</code> o en la carpeta <code>fire/*.py</code> del directorio donde se lanza.</p>"},{"location":"es/user-guide/decorators/#personalizacion","title":"Personalizaci\u00f3n","text":"<p>Si necesitas modificar el comportamiento de un comando: - Puedes ajustar las opciones y argumentos en el decorador. - Utiliza docstrings claros para definir la ayuda del comando. - Explora la implementaci\u00f3n de <code>@command.fire</code> en <code>clifire/command.py</code> para ver c\u00f3mo se procesa la informaci\u00f3n.</p> <p>Con este mecanismo basado en decoradores, CliFire te permite construir comandos de forma r\u00e1pida, manteniendo el c\u00f3digo limpio y organizado.</p> <p>\u00a1Empieza a usar decoradores para simplificar la creaci\u00f3n de tus comandos y aprovecha la flexibilidad que ofrece CliFire!</p>"},{"location":"es/user-guide/grouped-commands/","title":"Comandos Agrupados en CliFire","text":"<p>CliFire permite organizar los comandos en grupos utilizando una convenci\u00f3n de nomenclatura basada en puntos. Esto es especialmente \u00fatil cuando tu aplicaci\u00f3n CLI tiene muchas funcionalidades, ya que mejora la legibilidad y la organizaci\u00f3n.</p>"},{"location":"es/user-guide/grouped-commands/#como-funciona","title":"\u00bfC\u00f3mo funciona?","text":"<p>Para agrupar comandos, simplemente define el nombre del comando utilizando un punto (<code>.</code>) para separar el nombre del grupo y el comando espec\u00edfico. Por ejemplo, para agrupar comandos relacionados a la base de datos, puedes usar nombres como <code>db.create</code> y <code>db.drop</code>.</p> <p>Cuando se registra el comando, la funcionalidad de ayuda de CliFire (por ejemplo, en el comando de ayuda) detecta el car\u00e1cter <code>.</code> y agrupa autom\u00e1ticamente los comandos bajo el mismo grupo.</p>"},{"location":"es/user-guide/grouped-commands/#ejemplo-de-definicion-de-comandos-agrupados","title":"Ejemplo de definici\u00f3n de comandos agrupados","text":"<p>Quien define el grupo es la variable  <code>_name</code> de la clase <code>Command</code>, o el nombre del m\u00e9todo en los decoradores.</p> <p>Aqu\u00ed tienes un ejemplo de c\u00f3mo definir comandos agrupados utilizando clases: <pre><code>from clifire import command, out\n\nclass DbCreateCommand(command.Command):\n    _name = \"db.create\"\n    _help = \"Create the database\"\n\n    def run(self):\n        out.info(\"Database created.\")\n\nclass DbDropCommand(command.Command):\n    _name = \"db.drop\"\n    _help = \"Drop a database\"\n\n    def run(self):\n        out.info(\"Database removed.\")\n</code></pre></p>"},{"location":"es/user-guide/grouped-commands/#registro-y-ejecucion","title":"Registro y ejecuci\u00f3n","text":"<p>Registra los comandos en tu aplicaci\u00f3n:</p> <pre><code>from clifire import application\n\napp = application.App(name=\"MyApp CLI\", version=\"1.0\")\napp.add_command(CommandDbCreate)\napp.add_command(CommandDbDrop)\n</code></pre> <p>Luego, al ejecutar el comando de ayuda:</p> <pre><code>$ fire help\n</code></pre> <p>La salida mostrar\u00e1 los comandos agrupados, por ejemplo:</p> <pre><code>Available Commands:\n\n  db\n    create          Create the database\n    drop            Drop the database\n</code></pre>"},{"location":"es/user-guide/grouped-commands/#uso-de-los-comandos-agrupados-en-los-decoradores","title":"Uso de los comandos agrupados en los decoradores","text":"<p>Puedes usar la misma convenci\u00f3n de agrupaci\u00f3n con los decoradores para agrupar los comandos, en este caso, los grupos se obtienen del nombre del m\u00e9todo usando el car\u00e1cter <code>_</code>:</p> <pre><code>from clifire import command\n\n@command.fire\ndef db_create(cmd):\n    \"\"\"\n    Create the database\n    \"\"\"\n    out.info(\"Database created.\")\n\n@command.fire\ndef db_drop(cmd):\n    \"\"\"\n    Drop the database.\n    \"\"\"\n    out.info(\"Database removed.\")\n</code></pre>"},{"location":"es/user-guide/grouped-commands/#consejos-adicionales","title":"Consejos adicionales","text":"<ul> <li>Consistencia en los nombres: Aseg\u00farate de seguir una convenci\u00f3n coherente al nombrar tus comandos (por ejemplo, <code>grupo.comando</code>) para que el agrupamiento sea intuitivo.</li> <li>Subgrupos: Si lo necesitas, puedes definir m\u00e1s niveles de agrupaci\u00f3n utilizando m\u00e1s de un punto (por ejemplo, <code>db.table.create</code>).</li> <li>Personalizaci\u00f3n de la ayuda: Puedes extender la funcionalidad del comando de ayuda para modificar c\u00f3mo se muestran los grupos si fuera necesario.</li> </ul> <p>Con esta estructura, podr\u00e1s organizar tus comandos de forma clara y brindar una mejor experiencia a los usuarios de tu aplicaci\u00f3n CLI.</p>"},{"location":"es/user-guide/options-arguments/","title":"Opciones y Argumentos en CliFire","text":"<p>En CliFire, los comandos pueden recibir datos tanto como argumentos posicionados como opciones. Estos se definen mediante la clase <code>Field</code> en el m\u00f3dulo <code>command</code>.</p>"},{"location":"es/user-guide/options-arguments/#definicion-de-campos","title":"Definici\u00f3n de Campos","text":"<p>Cada campo que se declara como atributo en un comando se reconoce como:</p> <ul> <li> <p>Argumento Posicionado:   Si el campo tiene un valor de <code>pos</code> definido (por ejemplo, <code>pos=1</code>), se trata de un argumento que se espera en un orden determinado.   Los argumentos se asignan en base a su posici\u00f3n en la l\u00ednea de comandos.</p> </li> <li> <p>Opci\u00f3n:   Si <code>pos</code> es <code>False</code> o <code>None</code>, el campo se interpreta como una opci\u00f3n.   Estas se indican en la l\u00ednea de comandos con un gui\u00f3n simple o doble (por ejemplo, <code>-v</code> o <code>--verbose</code>).   Adem\u00e1s, se pueden definir alias para facilitar su uso.</p> </li> </ul>"},{"location":"es/user-guide/options-arguments/#ejemplo-de-definicion-en-un-comando","title":"Ejemplo de Definici\u00f3n en un Comando","text":"<pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Example command using options and arguments\"\n\n    # Argumento posicionado (por ejemplo, el primer argumento luego del nombre del comando)\n    filename = command.Field(\n        pos=1,\n        help=\"Name of the file to process\",\n        default=\"default.txt\",  # default value if not specified\n    )\n\n    # Opci\u00f3n que se activa con bandeja (por ejemplo, -v para verbose)\n    verbose = command.Field(\n        pos=False,\n        help=\"Detailed mode\",\n        default=False,\n        alias=[\"v\"],\n    )\n\n    # Opci\u00f3n que espera un valor (por ejemplo, --level=3)\n    level = command.Field(\n        pos=False,\n        help=\"Level of detail\",\n        default=1,\n        alias=[\"l\"],\n        force_type=int,\n    )\n\n    def run(self):\n        out.info(f\"File: {self.filename}\")\n        out.info(f\"Verbose: {self.verbose}\")\n        out.info(f\"Level: {self.level}\")\n</code></pre> <p>En este ejemplo: - <code>filename</code> es un argumento posicionado: se asigna el primer valor no asociado a una opci\u00f3n. - <code>verbose</code> es una opci\u00f3n booleana: se activa con <code>-v</code> o <code>--verbose</code>. - <code>level</code> es una opci\u00f3n que espera un valor num\u00e9rico, pudiendo usarse de la forma <code>--level=3</code> o <code>-l 3</code>.</p>"},{"location":"es/user-guide/options-arguments/#proceso-de-parseo-y-conversion","title":"Proceso de Parseo y Conversi\u00f3n","text":"<p>Cuando se ejecuta un comando: 1. Parseo:    CliFire lee la l\u00ednea de comandos y separa los argumentos y opciones utilizando <code>shlex.split()</code>.    Los argumentos posicionados se asignan seg\u00fan el orden definido en la propiedad <code>_argument_names</code> del comando.</p> <ol> <li>Conversi\u00f3n de Valores:    Cada campo utiliza su m\u00e9todo <code>convert</code> para transformar el valor recibido de cadena a su tipo esperado.    Por ejemplo:</li> <li>Si se define el campo <code>level</code> con <code>force_type=int</code>, la cadena se convertir\u00e1 a entero.</li> <li> <p>Si el campo es de tipo <code>list</code>, se puede usar una separaci\u00f3n por comas para obtener una lista de elementos.</p> </li> <li> <p>Validaciones:</p> </li> <li>Si un campo es obligatorio (sin valor por defecto), se comprueba que se haya proporcionado un valor.</li> <li>Las opciones pueden tener alias; estos se normalizan (por ejemplo, eliminando guiones y reemplazando <code>-</code> por <code>_</code>) para evitar duplicados.</li> </ol>"},{"location":"es/user-guide/options-arguments/#ejecucion-de-un-comando-con-opciones-y-argumentos","title":"Ejecuci\u00f3n de un Comando con Opciones y Argumentos","text":"<p>Al ejecutar el comando anterior desde la terminal, podr\u00edas tener diferentes comportamientos:</p> <pre><code>$ fire test myfile.txt -v --level=5\n</code></pre> <ul> <li>El valor <code>\"myfile.txt\"</code> se asignar\u00e1 a <code>filename</code>.</li> <li>La opci\u00f3n <code>-v</code> har\u00e1 que <code>verbose</code> sea <code>True</code>.</li> <li>El argumento <code>--level=5</code> se convertir\u00e1 a entero (<code>5</code>) y se asignar\u00e1 a <code>level</code>.</li> </ul> <p>Si no se proporcionan algunos de estos valores, se utilizar\u00e1n los valores por defecto definidos.</p>"},{"location":"es/user-guide/options-arguments/#conclusion","title":"Conclusi\u00f3n","text":"<p>Gracias a esta estructura flexible, CliFire permite definir de forma sencilla c\u00f3mo se reciben y procesan los datos en tus comandos. Puedes combinar argumentos posicionados y opciones con alias, validaci\u00f3n y conversi\u00f3n autom\u00e1tica de tipos, lo que facilita la construcci\u00f3n de interfaces de l\u00ednea de comandos robustas y f\u00e1ciles de usar.</p> <p>\u00a1Experimenta creando tus propios comandos y ajustando las opciones seg\u00fan las necesidades de tu aplicaci\u00f3n!</p>"},{"location":"es/user-guide/output/","title":"M\u00f3dulo <code>out</code>: Salidas y Estilos","text":"<p>El m\u00f3dulo <code>out</code> de CliFire facilita la impresi\u00f3n de mensajes en la terminal con distintos estilos y colores, aprovechando la potencia de la biblioteca Rich. Con estas funciones podr\u00e1s mostrar informaci\u00f3n, advertencias, errores, mensajes de \u00e9xito, depuraciones y hasta actualizaciones en vivo.</p>"},{"location":"es/user-guide/output/#funciones-principales","title":"Funciones Principales","text":"<p>Importa el m\u00f3dulo <code>out</code> en tu aplicaci\u00f3n de la siguiente manera:</p> <p><pre><code>from clifire import out\n</code></pre> A continuaci\u00f3n, se describen las funciones m\u00e1s utilizadas:</p> <ul> <li> <p><code>out.info(text: str) -&gt; None</code>   Muestra un mensaje informativo.   <pre><code>out.info(\"This is an informational message\")\n</code></pre></p> </li> <li> <p><code>out.success(text: str) -&gt; None</code>   Muestra un mensaje de \u00e9xito, ideal para indicar que una operaci\u00f3n se complet\u00f3 correctamente.   <pre><code>out.success(\"Operation completed successfully\")\n</code></pre></p> </li> <li> <p><code>out.warn(text: str) -&gt; None</code>   Imprime un mensaje de advertencia, \u00fatil cuando se requiere precauci\u00f3n en la ejecuci\u00f3n.   <pre><code>out.warn(\"Warning: check your configuration\")\n</code></pre></p> </li> <li> <p><code>out.error(text: str) -&gt; None</code>   Muestra un mensaje de error de forma destacada para indicar fallos cr\u00edticos en el proceso.   <pre><code>out.error(\"Critical error occurred\")\n</code></pre></p> </li> <li> <p><code>out.debug(text: str) -&gt; None</code>   Imprime mensajes de depuraci\u00f3n, lo que resulta \u00fatil durante el desarrollo para rastrear el comportamiento interno.   <pre><code>out.debug(\"Debug: variable x = 42\")\n</code></pre></p> </li> <li> <p><code>out.var_dump(var) -&gt; None</code>   Imprime de manera legible el contenido de una variable, resaltando su estructura para facilitar su inspecci\u00f3n.   <pre><code>sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\nout.var_dump(sample_dict)\n</code></pre></p> </li> <li> <p><code>out.LiveText</code>   Es una clase que permite actualizar en vivo la salida de texto en la terminal. Es \u00fatil para mostrar barras de progreso o contadores que se actualizan din\u00e1micamente.   <pre><code>live_text = out.LiveText(\"Starting...\")\nlive_text.info(\"Process running\")\nlive_text.warn(\"Retrying operation\")\nlive_text.success(\"Operation completed\", end=False)\n</code></pre></p> </li> </ul>"},{"location":"es/user-guide/output/#uso-general","title":"Uso General","text":"<p>El m\u00f3dulo <code>out</code> est\u00e1 dise\u00f1ado para integrarse de forma transparente en tus comandos y aplicaciones creadas con CliFire, brindando un formato est\u00e1ndar y estilizado para la salida en la terminal. Cada funci\u00f3n aplica estilos predefinidos para mantener una experiencia consistente y atractiva.</p> <p>A continuaci\u00f3n, se muestra un ejemplo completo:</p> <pre><code>import time\n\nfrom clifire import application, command, out\n\n\nclass OutCommand(command.Command):\n    _name = 'out'\n\n    def fire(self):\n        print('Text colors')\n        print('-' * 80)\n        out.info(\"This is an informational message\")\n        out.success(\"Operation completed successfully\")\n        out.warn(\"Warning: check your configuration\")\n        out.error(\"Critical error occurred\")\n\n        print('')\n        print('Debug')\n        print('-' * 80)\n        out.debug(\"Debug: variable x = 42\")\n        sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\n        out.var_dump(sample_dict)\n\n        print('')\n        print('Tables')\n        print('-' * 80)\n        data = [\n            {\"name\": \"Luke\", \"age\": 18, \"is_student\": True},\n            {\"name\": \"Elizabeth\", \"age\": 101, \"is_student\": False},\n        ]\n        out.table(data, border=True, title=\"Contacts\")\n\n        print('')\n        print('Live text')\n        print('-' * 80)\n        live_text = out.LiveText(\"Starting...\")\n        time.sleep(1)\n        live_text.info(\"Process running\")\n        time.sleep(1)\n        live_text.warn(\"Retrying operation\")\n        time.sleep(1)\n        live_text.success(\"Operation completed\", end=False)\n        time.sleep(1)\n\n\ndef main():\n    app = application.App()\n    app.add_command(OutCommand)\n    app.fire(\"out -v\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p>"},{"location":"es/user-guide/output/#personalizacion","title":"Personalizaci\u00f3n","text":"<p>El m\u00f3dulo <code>out</code> utiliza un objeto de consola de Rich (<code>out.CONSOLE</code>) que puede ser personalizado. Si necesitas cambiar los estilos o modificar el comportamiento visual, puedes configurar dicho objeto o consultar la documentaci\u00f3n de Rich para m\u00e1s opciones.</p> <p>Con esta gu\u00eda tendr\u00e1s una visi\u00f3n general de c\u00f3mo utilizar el m\u00f3dulo <code>out</code> para mejorar la presentaci\u00f3n de mensajes en tus aplicaciones CLI creadas con CliFire.</p>"},{"location":"es/user-guide/templates/","title":"Plantillas en CliFire","text":"<p>El m\u00f3dulo <code>Template</code> de CliFire permite renderizar y guardar archivos usando plantillas basadas en Jinja2. Esta funcionalidad te ayuda a generar contenido din\u00e1mico de manera sencilla, ideal para crear archivos de configuraci\u00f3n, reportes u otros documentos que requieran personalizaci\u00f3n.</p> <p>Puede usar el m\u00f3dulo <code>Template</code> de manera independiente, o puede usarlo dentro de la clase <code>App</code> para manejar la configuraci\u00f3n de su aplicaci\u00f3n CLI.</p> <p>El fichero <code>sample_template/hello.jinja2</code> es un ejemplo de plantilla que se puede usar con el m\u00f3dulo <code>Template</code>. Aqu\u00ed tienes un ejemplo de c\u00f3mo se ver\u00eda el contenido de la plantilla:</p> <pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;ul&gt;\n    {% for number in numbers %}\n        &lt;li&gt;{{ number }}&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n</code></pre> <p>El comando CLI se llamar\u00e1 <code>app_template.py</code> y se ver\u00e1 as\u00ed: <pre><code>from clifire import application, command, out\n\n\nclass HelloCommand(command.Command):\n    _name = \"hello\"\n    _help = \"Create template\"\n\n    title = command.Field(\n        pos=1,\n        force_type=str,\n    )\n\n    def fire(self):\n        print(self.title)\n        content = self.app.template.render(\n            'hello.jinja2', title=self.title, numbers=[1, 2, 3])\n        out.success(content)\n\n\ndef main():\n    app = application.App(template_folder=\"./sample_template\")\n    app.add_command(HelloCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Con esto al ejecutarlo tendr\u00e1s un comando que renderiza la plantilla <code>hello.jinja2</code> con el t\u00edtulo y una lista de n\u00fameros, mostrando el resultado en la terminal.</p> <p></p>"},{"location":"es/user-guide/templates/#funciones-principales","title":"Funciones Principales","text":"<ul> <li><code>Template.render(template: str, **args) -&gt; str</code>   Renderiza una plantilla especificada. Recibe el nombre del archivo de plantilla y par\u00e1metros adicionales que se utilizar\u00e1n para sustituir las variables definidas en la plantilla.</li> </ul> <p>Ejemplo:   <pre><code>from clifire import template\n\n# Crea el objeto Template especificando la carpeta donde se encuentran las plantillas.\ntpl = template.Template(\"templates\")\ncontent = tpl.render(\"sample.jinja2\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n\n# 'content' contendr\u00e1 el HTML generado con los valores proporcionados.\nprint(content)\n</code></pre></p> <ul> <li><code>Template.write(template: str, filename: str, mark: Optional[str] = None, **args) -&gt; str</code>   Renderiza la plantilla y guarda su contenido en un fichero.   Si se especifica un par\u00e1metro <code>mark</code>, el contenido renderizado se insertar\u00e1 o se reemplazar\u00e1 entre marcas especiales en el fichero; esto es \u00fatil para actualizar secciones espec\u00edficas sin sobrescribir el resto del contenido.</li> </ul> <p>Ejemplo sin marca:   <pre><code>tpl = template.Template(\"templates\")\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p> <p>Ejemplo con marca:   <pre><code>tpl = template.Template(\"templates\")\n# El marcado '&lt;&lt;CONTENT&gt;&gt;' delimitar\u00e1 la secci\u00f3n a actualizar.\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p>"},{"location":"es/user-guide/templates/#como-funciona","title":"\u00bfC\u00f3mo Funciona?","text":"<ol> <li> <p>Renderizado de Plantillas:    El m\u00e9todo <code>render</code> carga el archivo de plantilla utilizando Jinja2 y lo procesa con los argumentos proporcionados. Esto te permite generar contenido din\u00e1mico basado en variables definidas en tu plantilla.</p> </li> <li> <p>Guardado y Actualizaci\u00f3n de Archivos:    Con el m\u00e9todo <code>write</code>, puedes almacenar directamente el contenido renderizado en un fichero.    Si especificas un <code>mark</code>:</p> </li> <li>El m\u00e9todo busca dentro del fichero la secci\u00f3n delimitada por esa marca.</li> <li>Si encuentra la secci\u00f3n, la reemplaza con el nuevo contenido renderizado.</li> <li> <p>Si no existe, a\u00f1ade la secci\u00f3n al final del fichero.    Esto permite actualizar partes espec\u00edficas del fichero sin perder el contenido original que se encuentre fuera de las marcas.</p> </li> <li> <p>Integraci\u00f3n Din\u00e1mica:    El objeto <code>Template</code> se integra con el resto de CliFire, permiti\u00e9ndote utilizar variables de entorno o cualquier otra l\u00f3gica de negocio durante el renderizado.</p> </li> </ol>"},{"location":"es/user-guide/templates/#ejemplo-completo","title":"Ejemplo Completo","text":"<pre><code>from clifire import template\n\ndef generate_report():\n    # Inicializa la plantilla indicando la carpeta de plantillas\n    tpl = template.Template(\"templates\")\n\n    # Renderiza la plantilla sample.jinja2 con datos din\u00e1micos\n    content = tpl.render(\"sample.jinja2\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n    print(\"Rendered Content:\")\n    print(content)\n\n    # Guarda el contenido renderizado en output.html sin usar marcas\n    tpl.write(\"sample.jinja2\", \"output.html\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\n    # Guarda el contenido en output_marked.html utilizando una marca para actualizar solo una secci\u00f3n\n    tpl.write(\"sample.jinja2\", \"output_marked.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\nif __name__ == \"__main__\":\n    generate_report()\n</code></pre>"},{"location":"es/user-guide/templates/#conclusion","title":"Conclusi\u00f3n","text":"<p>El m\u00f3dulo <code>Template</code> permite separar la l\u00f3gica del contenido de la presentaci\u00f3n, facilitando la generaci\u00f3n de ficheros din\u00e1micos a partir de plantillas. Esto mejora la mantenibilidad y la flexibilidad de tus aplicaciones CLI, permiti\u00e9ndote actualizar secciones espec\u00edficas de un fichero sin afectar el resto del contenido.</p> <p>Esta funcionalidad es especialmente \u00fatil para proyectos que requieran la creaci\u00f3n o actualizaci\u00f3n peri\u00f3dica de reportes, ficheros de configuraci\u00f3n, o cualquier otro tipo de documento basado en plantillas.</p>"},{"location":"en/en/","title":"CliFire","text":"<p>Minimal CLI framework to build Python commands quickly and elegantly.</p> <p>CliFire is a lightweight library designed to simplify the creation of command line interfaces (CLI). It allows developers to define commands, options, and arguments easily, facilitating the building of complex CLI applications without the overhead of larger frameworks.</p> <p>The idea behind CliFire is to enable you to create CLIs quickly and effortlessly by leveraging Python's features. Its minimalist approach and intuitive syntax make it easy to learn and use, allowing developers to focus on the logic of their applications rather than on CLI infrastructure.</p> <p>Additionally, with the <code>fire</code> command, you can create dynamic commands directly from the terminal, providing an interactive and flexible experience.</p>"},{"location":"en/en/#main-features","title":"Main Features","text":"<ul> <li>Two usage styles: decorators for a simple approach or classes for greater customization.</li> <li>Intuitive syntax: focused on simplicity and readability.</li> <li>Global and per-command options: flexible parameter configuration.</li> <li>Grouped commands: organizes related commands hierarchically.</li> <li>Formatted output: uses Rich to display messages with colors and styles.</li> <li>Built-in templates: creates files using Jinja2.</li> <li>Centralized configuration: easily manage your application's configuration.</li> </ul>"},{"location":"en/en/#quick-installation","title":"Quick Installation","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"en/en/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"en/en/changelog/#011-2025-06-07","title":"[0.1.1] - 2025-06-07","text":""},{"location":"en/en/changelog/#added","title":"Added","text":"<ul> <li>Bash command <code>clifire</code>  for creating dynamic commands.</li> <li>In application module, added:</li> <li>Global option <code>--verbose</code> created by default.</li> <li>If no command is passed, help is shown if the help command is defined.</li> <li>New <code>path</code> method for get absolute path to a filename.</li> <li>New <code>config</code> variable for managing configuration settings.</li> <li>New <code>template</code> variable for creating files with jinja2.</li> <li>In out module, added:</li> <li><code>debug</code> method for printing debug messages.</li> <li><code>debug2</code> method for printing debug messages level 2.</li> <li><code>var_dump</code> method for printing pretty variables in out module.</li> <li>New <code>Config</code> class to manage configuration settings.</li> <li>New <code>Template</code> class for creating files with jinja2.</li> <li>Changed relative imports to module imports for better compatibility.</li> </ul>"},{"location":"en/en/changelog/#changed","title":"Changed","text":"<ul> <li>Commands now use <code>fire()</code> method instead of <code>run()</code>.</li> <li>Compatibility with Python 3.10.</li> <li>Updated documentation to include usage examples for the new <code>clifire</code> command.</li> <li>Enhanced the <code>--verbose</code> option to provide more detailed output during command execution.</li> <li>Improved Result class, stdout and stderr are now str instead of list</li> </ul>"},{"location":"en/en/changelog/#fixed","title":"Fixed","text":"<ul> <li>The arguments between quotes are now correctly parsed, allowing for spaces in arguments.</li> <li>The [options] message in <code>help</code> command not correctly displayed.</li> </ul>"},{"location":"en/en/changelog/#removed","title":"Removed","text":""},{"location":"en/en/changelog/#010-2025-06-01","title":"[0.1.0] - 2025-06-01","text":""},{"location":"en/en/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release with the first usable version.</li> </ul>"},{"location":"en/en/contributing/","title":"Contribute to CliFire","text":"<p>Thank you for your interest in contributing to CliFire!</p> <p>Contributions are welcome and help improve this minimalistic project designed to build CLI applications in Python.</p>"},{"location":"en/en/contributing/#how-to-contribute","title":"How to Contribute","text":"<p>There are several ways you can help:</p> <ul> <li>Reporting Bugs: If you find a bug or unexpected behavior, please open an issue on GitHub with a detailed description and, if possible, steps to reproduce it.</li> <li>Requesting New Features: If you have an idea to improve CliFire, open an issue or propose a pull request.</li> <li>Code and Improvements: If you wish to submit code, make sure you follow the project's style guidelines and add unit tests to support your changes.</li> <li>Documentation: Help improve the documentation by correcting errors, expanding sections, or adding usage examples.</li> </ul>"},{"location":"en/en/contributing/#contribution-workflow","title":"Contribution Workflow","text":""},{"location":"en/en/contributing/#fork-the-repository","title":"Fork the Repository","text":"<p>Fork the project on GitHub.</p>"},{"location":"en/en/contributing/#clone-your-fork-locally","title":"Clone your fork locally:","text":"<pre><code>git clone https://github.com/your-user/clifire.git\ncd clifire\n</code></pre>"},{"location":"en/en/contributing/#create-a-branch-for-your-changes","title":"Create a Branch for your Changes:","text":"<pre><code>git checkout -b my-changes\n</code></pre>"},{"location":"en/en/contributing/#make-your-changes","title":"Make your Changes:","text":"<p>Make the necessary changes in the code. Ensure that:</p> <ul> <li>You follow the project's style guidelines.</li> <li>You add unit tests\u2014the project has 100% coverage!</li> <li>You update or add documentation where necessary.</li> </ul>"},{"location":"en/en/contributing/#run-the-tests","title":"Run the Tests:","text":"<p>Make sure all tests pass using:    <pre><code>poetry run pytest\n</code></pre>    Check the coverage with:    <pre><code>poetry run coverage run -m pytest &amp;&amp; poetry run coverage html\n</code></pre></p> <p>You can also use <code>poetry run fire coverage</code> to run the tests and generate the coverage report.</p>"},{"location":"en/en/contributing/#submit-a-pull-request","title":"Submit a Pull Request:","text":"<p>Once you are satisfied with your changes, submit a pull request to the main branch of the repository. Describe in detail what you have changed and the motivation behind it.</p>"},{"location":"en/en/contributing/#best-practices","title":"Best Practices","text":"<ul> <li>Write clear and descriptive commit messages.</li> <li>Follow the Keep a Changelog format to document your changes.</li> <li>Ensure that new features or fixes do not break existing compatibility.</li> <li>Respect the format and structure of the existing documentation.</li> </ul>"},{"location":"en/en/contributing/#review-and-feedback","title":"Review and Feedback","text":"<p>Your pull request will be reviewed by the project maintainers. They may ask for adjustments or clarifications, so please pay close attention to any comments!</p> <p>For further details, refer to the Complete Contribution Guide in the repository.</p> <p>Thank you for helping CliFire grow and improve!</p>"},{"location":"en/en/quick-start/","title":"Quick Start Guide - Getting Started with CliFire","text":"<p>Welcome to the Quick Start Guide for CliFire, a minimalist framework for creating command line interfaces in Python quickly and elegantly.</p>"},{"location":"en/en/quick-start/#installation","title":"Installation","text":"<p>You can install CliFire from PyPI or directly using Poetry:</p>"},{"location":"en/en/quick-start/#from-pypi","title":"From PyPI","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"en/en/quick-start/#using-poetry","title":"Using Poetry","text":"<pre><code>poetry add clifire\n</code></pre>"},{"location":"en/en/quick-start/#basic-usage","title":"Basic Usage","text":"<p>CliFire allows you to define commands using decorators or classes. Here\u2019s an example using a decorator to greet the user:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre>"},{"location":"en/en/quick-start/#running-the-command","title":"Running the Command","text":"<p>Save the file as <code>fire.py</code> or create a <code>fire</code> directory and place the file inside with a <code>.py</code> extension.</p> <p>Help is automatically built from the docstring, allowing users to quickly understand how to use the command:</p> <p></p> <p>You can run the <code>greet</code> command directly: </p>"},{"location":"en/en/quick-start/#main-features","title":"Main Features","text":"<ul> <li>Simple Command Definition: Use decorators or classes to create dynamic commands.</li> <li>Handling of Arguments and Options: Define arguments and options to customize the behavior of your commands.</li> <li>Formatted Output: Uses the <code>out</code> module to display messages with styles and colors by leveraging the Rich library.</li> <li>Centralized Configuration: Manage your application's configuration through the <code>Config</code> class.</li> <li>File Templates: Create files using Jinja2 templates via the <code>Template</code> class.</li> </ul>"},{"location":"en/en/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>For more details on the API and configuration, consult the User Documentation.</li> <li>Check the API Reference to see all available functions and classes.</li> <li>Look at practical examples in the Examples section.</li> </ul> <p>Start creating your commands and enjoy a minimalist and powerful experience with CliFire!</p>"},{"location":"en/en/user-guide/basics/","title":"CliFire Basics","text":"<p>CliFire is a minimalist framework for creating command line applications in Python in a simple and elegant way. This guide introduces you to the fundamental concepts so you can start using it quickly.</p> <p>We offer two approaches to use CliFire, via decorators or via classes:</p> <ul> <li>Decorators: They allow you to define commands quickly and easily without losing power or flexibility.</li> <li>Classes: They offer more detailed control over a command\u2019s behavior, ideal for more complex applications.</li> </ul> <p>The idea behind CliFire is to enable you to create CLI (Command Line Interface) applications quickly and easily by leveraging Python's features.</p>"},{"location":"en/en/user-guide/basics/#1-commands","title":"1. Commands","text":"<p>Commands are the essence of your CLI application. You can define them in two ways:</p> <ul> <li>Using decorators:   Command creation is simplified with the <code>@command.fire</code> decorator.</li> </ul> <pre><code>from clifire import command, out\n\n@command.fire\ndef hello(cmd, name: str = \"World\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user. Defaults to \"World\".\n    \"\"\"\n    out.info(f\"Hello, {name}!\")\n</code></pre> <ul> <li>Using classes:   Create a class that inherits from <code>command.Command</code> for more control over the command's behavior.</li> </ul> <pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    def fire(self):\n        out.info(\"Executing test command\")\n</code></pre>"},{"location":"en/en/user-guide/basics/#2-arguments-and-options","title":"2. Arguments and Options","text":"<p>CliFire allows you to define:</p> <ul> <li>Global Options: Settings that affect the entire application (for example, verbose mode).</li> <li>Local Options: Specific arguments and options for each command.</li> </ul> <p>These options can be set using the <code>Field</code> class from the <code>command</code> module.</p> <pre><code>from clifire import command\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    bool_option = command.Field(\n        pos=1,\n        help=\"Example boolean option\",\n        default=False,\n        alias=[\"-v\"],\n    )\n\n    def fire(self):\n        if self.bool_option:\n            print(\"Verbose option enabled\")\n        else:\n            print(\"Verbose option disabled\")\n</code></pre>"},{"location":"en/en/user-guide/basics/#3-configuration","title":"3. Configuration","text":"<p>The <code>Config</code> class manages your application's configuration. It allows you to read data from YAML files and write it, excluding private fields (those that begin with <code>_</code>).</p> <pre><code>from clifire import config\n\nconf = config.Config(config_file=\"config.yaml\")\nconf.name = \"MyApp\"\nconf.version = \"1.0.0\"\nconf.write()\n</code></pre> <p>Note: Private fields (e.g., <code>_secret</code>) are not saved in the configuration file.</p>"},{"location":"en/en/user-guide/basics/#4-output-and-styling","title":"4. Output and Styling","text":"<p>The <code>out</code> module uses the Rich library to display messages with different styles and colors:</p> <ul> <li><code>out.info()</code>: Information.</li> <li><code>out.success()</code>: Success.</li> <li><code>out.warn()</code>: Warning.</li> <li><code>out.error()</code>: Error.</li> </ul> <pre><code>from clifire import out\n\nout.info(\"This is an informational message\")\n</code></pre>"},{"location":"en/en/user-guide/basics/#5-templates","title":"5. Templates","text":"<p>The <code>Template</code> class allows you to generate files from Jinja2 templates. This is useful for creating files with dynamic content in an easy way.</p> <pre><code>from clifire import template\n\ntpl = template.Template(template_folder=\"templates\")\ncontent = tpl.render(\n    \"sample.jinja2\",\n    title=\"My Title\",\n    user=\"admin\",\n    items=[\"data1\", \"data2\"]\n)\n</code></pre> <p>Moreover, the <code>write</code> function of the template lets you save the rendered content to a file, with the option to insert or replace content delimited by markers.</p> <p>This is useful for generating configuration files or custom scripts that can be easily updated in the future without affecting the rest of the file.</p>"},{"location":"en/en/user-guide/basics/#6-execution-flow","title":"6. Execution Flow","text":"<ol> <li> <p>Command Definition:    Commands are defined using decorators or classes.</p> </li> <li> <p>Command Registration:    When the <code>App</code> is instantiated, commands are registered. By default, a help command is added that shows information about all available commands.</p> </li> <li> <p>Parsing and Execution:    When the application is run, the command line is parsed, the command to execute is identified, and its options and arguments are processed.</p> </li> </ol>"},{"location":"en/en/user-guide/basics/#conclusion","title":"Conclusion","text":"<p>With these basic concepts, you are ready to start using CliFire in your projects. The simplicity and flexibility of this framework will allow you to build powerful and customized CLI applications without complications.</p> <p>For more details and advanced examples, consult the User Documentation and the API Reference.</p>"},{"location":"en/en/user-guide/classes/","title":"Class-based Commands","text":"<p>In addition to using decorators, CliFire allows you to define commands using classes. This approach is useful when you need more customization or complex logic in your commands.</p>"},{"location":"en/en/user-guide/classes/#defining-a-command-with-classes","title":"Defining a Command with Classes","text":"<p>To create a class-based command, inherit from <code>command.Command</code> and set the following properties:</p> <ul> <li><code>_name</code>: The name of the command. If you want to group commands, use dots (for example, <code>db.create</code>).</li> <li><code>_help</code>: A brief description that will be displayed in the help.</li> <li>Fields/Arguments: Define arguments and options as class attributes using <code>command.Field</code>.</li> </ul> <p>Basic example:</p> <pre><code>from clifire import command, out\n\nclass CommandGreet(command.Command):\n    _name = \"greet\"\n    _help = \"Greets the user in a personalized way\"\n\n    # Define a field for the name (non-option argument)\n    name = command.Field(\n        pos=1,\n        help=\"User's name\",\n        default=\"World\",\n        alias=[],\n    )\n\n    # Define a field to enable informal greeting (option)\n    informal = command.Field(\n        pos=None,\n        help=\"Use informal greeting\",\n        default=False,\n        alias=[\"-i\"],\n    )\n\n    def fire(self):\n        if self.informal:\n            out.info(f\"Hello, {self.name}! How's it going?\")\n        else:\n            out.info(f\"Good morning, {self.name}!\")\n</code></pre>"},{"location":"en/en/user-guide/classes/#registration-and-execution","title":"Registration and Execution","text":"<p>When the application is instantiated, the command is registered and can be executed from the command line:</p> <pre><code>$ fire greet\nGood morning, World!\n\n$ fire greet Alice -i\nHello, Alice! How's it going?\n</code></pre>"},{"location":"en/en/user-guide/classes/#advantages-of-the-class-based-approach","title":"Advantages of the Class-based Approach","text":"<ul> <li>Greater control and customization: You can define your own methods and attributes to handle complex use cases.</li> <li>Inheritance: You can create base commands and extend them to share common behaviors.</li> <li>Organization: Results in a clear and modular structure when you have a large number of commands.</li> </ul>"},{"location":"en/en/user-guide/classes/#internal-details","title":"Internal Details","text":"<p>When the application is instantiated, the commands defined as classes are registered. The application calls the <code>fire()</code> method of the corresponding command after parsing its arguments and options. Additionally:</p> <ul> <li>Fields are automatically updated based on the command parsing.</li> <li>Aliases and type conversions are managed in the <code>Field</code> class (see command.py).</li> </ul> <p>With this mechanism, you can take full advantage of Python's flexibility and create commands with advanced behaviors without complicating the function-level syntax.</p> <p>Explore and experiment by creating your own custom commands!</p>"},{"location":"en/en/user-guide/config/","title":"Configuration","text":"<p>The <code>Config</code> module in CliFire is responsible for managing your application's configuration through YAML files. It allows you to read and write the configuration while automatically ensuring that private fields (those whose names begin with <code>_</code>) are excluded.</p>"},{"location":"en/en/user-guide/config/#main-features","title":"Main Features","text":"<ul> <li> <p>Automatic Exclusion of Private Fields:   When writing the configuration, properties whose names start with <code>_</code> are excluded, ensuring that sensitive or internal information is not stored in the file.</p> </li> <li> <p>Flexible Loading of Configuration Files:   The class method <code>get_config</code> allows you to specify a list of possible configuration files. The first existing file is loaded or, if none exists, one can be created if the <code>create</code> option is enabled.</p> </li> <li> <p>Dynamic Attribute Management:   Configuration values are assigned as attributes of the <code>Config</code> instance, allowing you to access them dynamically using the <code>get</code> method.</p> </li> </ul>"},{"location":"en/en/user-guide/config/#usage-example","title":"Usage Example","text":"<p>You can use the <code>Config</code> module independently or within the <code>App</code> class to manage your CLI application's configuration.</p> <pre><code>from clifire import application, command, out\n\n\nclass ConfigCommand(command.Command):\n    _name = \"config\"\n    _help = \"Show config vars\"\n\n    def fire(self):\n        self.app.config.my_new_var = \"My new var\"\n        out.var_dump(self.app.config)\n\n\ndef main():\n    app = application.App(config_files=[\"~/.myapp.yml\"], config_create=True)\n    app.add_command(ConfigCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Now we can run it:</p> <p></p>"},{"location":"en/en/user-guide/config/#reading-the-configuration","title":"Reading the Configuration","text":"<p>To load your application's configuration, use the <code>get_config</code> method. For example:</p> <pre><code>from clifire import config\n\n# Attempt to load configuration from 'config.yaml' or 'default.yaml'\ncfg = config.Config.get_config([\"config.yaml\", \"default.yaml\"])\nif not cfg.read():\n    print(\"Configuration file not found.\")\nelse:\n    print(\"Configuration loaded successfully.\")\n    print(\"Application Name:\", cfg.get(\"name\"))\n</code></pre> <p>In this example, if the configuration file exists, the attributes of the <code>cfg</code> instance are updated. If it does not exist, <code>read()</code> returns <code>False</code>.</p>"},{"location":"en/en/user-guide/config/#writing-the-configuration","title":"Writing the Configuration","text":"<p>To save the current configuration to a file, use the <code>write()</code> method. Note how private fields are excluded:</p> <pre><code>from clifire import config\n\ncfg = config.Config(config_file=\"config.yaml\")\ncfg.name = \"MyApp\"\ncfg.version = \"1.0.0\"\ncfg._secret_key = \"my-secret-key\"  # This will not be saved\ncfg.write()\n</code></pre> <p>Private Field Exclusion</p> <p>All variables that begin with <code>_</code> will not be saved in the YAML file. This is useful for keeping sensitive or internal application data private.</p>"},{"location":"en/en/user-guide/config/#summary","title":"Summary","text":"<p>The <code>Config</code> module provides a simple and secure way to manage your CLI application's configuration using YAML files. When reading and writing configuration data, private fields are automatically excluded, which helps maintain both security and cleanliness of the stored data.</p> <p>This robust functionality facilitates centralized configuration management in CliFire, contributing to the flexibility and maintainability of your applications.</p>"},{"location":"en/en/user-guide/decorators/","title":"Decorators in CliFire","text":"<p>In CliFire, decorators simplify the creation and registration of commands in a clean and elegant way. With the <code>@command.fire</code> decorator, you can easily transform regular functions into CLI commands.</p>"},{"location":"en/en/user-guide/decorators/#what-is-a-decorator","title":"What is a Decorator?","text":"<p>In Python, a decorator is a function that receives another function and extends or modifies it without altering its structure. In the context of CliFire, the decorator:</p> <ul> <li>Registers the command in the application.</li> <li>Extracts information (name, arguments, docstring) needed for the command.</li> <li>Prepares the function to be invoked from the command line.</li> </ul>"},{"location":"en/en/user-guide/decorators/#using-the-commandfire-decorator","title":"Using the <code>@command.fire</code> Decorator","text":"<p>The <code>@command.fire</code> decorator is the simplest way to convert a function into a command within CliFire. For example, create the file <code>fire/greet.py</code> with the following content:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre> <p>By applying <code>@command.fire</code>:</p> <ul> <li>The <code>greet</code> function is transformed into a command object.</li> <li>Information such as the command name and its arguments is extracted from the docstring.</li> <li>The command is automatically registered to be used in the CLI.</li> </ul>"},{"location":"en/en/user-guide/decorators/#advantages-of-using-decorators","title":"Advantages of Using Decorators","text":"<ul> <li>Simplicity: Define commands in just a few lines of code.</li> <li>Organization: Separates command logic from CLI interface configuration.</li> <li>Flexibility: Allows you to define arguments and options using type annotations and docstring comments.</li> </ul>"},{"location":"en/en/user-guide/decorators/#automatic-command-registration","title":"Automatic Command Registration","text":"<p>When you define a function with <code>@command.fire</code>, the decorator performs the following operations:</p> <ol> <li>Obtains the command name using <code>func.__name__</code> or a custom attribute.</li> <li>Processes the docstring to extract the description and details for each argument.</li> <li>Dynamically creates a class that inherits from <code>command.Command</code> representing the command.</li> <li>Registers this command in the current application using <code>get_current_app().add_command(...)</code>.</li> </ol>"},{"location":"en/en/user-guide/decorators/#command-execution","title":"Command Execution","text":"<p>The help is automatically built from the docstring, enabling users to quickly understand how to use the command:</p> <p></p> <p>You can execute the <code>greet</code> command directly: </p>"},{"location":"en/en/user-guide/decorators/#the-fire-command","title":"The <code>fire</code> Command","text":"<p>The <code>fire</code> command is the main entry point for interacting with your CLI application. It allows you to execute commands and pass arguments and options.</p> <p><code>fire</code> searches for your commands either in a <code>fire.py</code> file or in the <code>fire/*.py</code> folder in the directory where it is launched.</p>"},{"location":"en/en/user-guide/decorators/#customization","title":"Customization","text":"<p>If you need to modify a command's behavior: - You can adjust the options and arguments in the decorator. - Use clear docstrings to define the command help. - Explore the implementation of <code>@command.fire</code> in <code>clifire/command.py</code> to see how the information is processed.</p> <p>With this decorator-based mechanism, CliFire allows you to build commands quickly while keeping your code clean and organized.</p> <p>Start using decorators to simplify the creation of your commands and take advantage of the flexibility that CliFire offers!</p>"},{"location":"en/en/user-guide/grouped-commands/","title":"Grouped Commands in CliFire","text":"<p>CliFire allows you to organize commands into groups using a dot-based naming convention. This is especially useful when your CLI application has many features, as it improves readability and organization.</p>"},{"location":"en/en/user-guide/grouped-commands/#how-it-works","title":"How It Works","text":"<p>To group commands, simply define the command name using a dot (<code>.</code>) to separate the group name from the specific command. For example, to group database-related commands, you can use names like <code>db.create</code> and <code>db.drop</code>.</p> <p>When the command is registered, CliFire's help functionality (for example, in the help command) detects the <code>.</code> character and automatically groups the commands under the same category.</p>"},{"location":"en/en/user-guide/grouped-commands/#example-of-defining-grouped-commands","title":"Example of Defining Grouped Commands","text":"<p>The group is determined by the <code>_name</code> variable of the <code>Command</code> class or the method name when using decorators.</p> <p>Here is an example of how to define grouped commands using classes: <pre><code>from clifire import command, out\n\nclass DbCreateCommand(command.Command):\n    _name = \"db.create\"\n    _help = \"Create the database\"\n\n    def run(self):\n        out.info(\"Database created.\")\n\nclass DbDropCommand(command.Command):\n    _name = \"db.drop\"\n    _help = \"Drop a database\"\n\n    def run(self):\n        out.info(\"Database removed.\")\n</code></pre></p>"},{"location":"en/en/user-guide/grouped-commands/#registration-and-execution","title":"Registration and Execution","text":"<p>Register the commands in your application:</p> <pre><code>from clifire import application\n\napp = application.App(name=\"MyApp CLI\", version=\"1.0\")\napp.add_command(DbCreateCommand)\napp.add_command(DbDropCommand)\n</code></pre> <p>Then, when running the help command:</p> <pre><code>$ fire help\n</code></pre> <p>The output will display the grouped commands, for example:</p> <pre><code>Available Commands:\n\n  db\n    create          Create the database\n    drop            Drop the database\n</code></pre>"},{"location":"en/en/user-guide/grouped-commands/#using-grouped-commands-with-decorators","title":"Using Grouped Commands with Decorators","text":"<p>You can use the same grouping convention with decorators to group commands. In this case, the groups are obtained from the method name by using the <code>_</code> character:</p> <pre><code>from clifire import command, out\n\n@command.fire\ndef db_create(cmd):\n    \"\"\"\n    Create the database\n    \"\"\"\n    out.info(\"Database created.\")\n\n@command.fire\ndef db_drop(cmd):\n    \"\"\"\n    Drop the database.\n    \"\"\"\n    out.info(\"Database removed.\")\n</code></pre>"},{"location":"en/en/user-guide/grouped-commands/#additional-tips","title":"Additional Tips","text":"<ul> <li>Name Consistency: Make sure to follow a consistent naming convention for your commands (e.g., <code>group.command</code>) so that the grouping is intuitive.</li> <li>Subgroups: If needed, you can define multiple levels of grouping by using more than one dot (e.g., <code>db.table.create</code>).</li> <li>Help Customization: You can extend the help command functionality to modify how groups are displayed if necessary.</li> </ul> <p>With this structure, you can organize your commands clearly and provide a better user experience for your CLI application.</p>"},{"location":"en/en/user-guide/options-arguments/","title":"Options and Arguments in CliFire","text":"<p>In CliFire, commands can receive data both as positional arguments and options. These are defined using the <code>Field</code> class in the <code>command</code> module.</p>"},{"location":"en/en/user-guide/options-arguments/#field-definition","title":"Field Definition","text":"<p>Each field declared as an attribute in a command is recognized as:</p> <ul> <li> <p>Positional Argument:   If the field has a defined <code>pos</code> value (for example, <code>pos=1</code>), it is treated as an argument that is expected in a certain order.   The arguments are assigned based on their position in the command line.</p> </li> <li> <p>Option:   If <code>pos</code> is <code>False</code> or <code>None</code>, the field is interpreted as an option.   Options are indicated on the command line with a single or double dash (for example, <code>-v</code> or <code>--verbose</code>).   Additionally, aliases can be defined to facilitate its usage.</p> </li> </ul>"},{"location":"en/en/user-guide/options-arguments/#example-of-field-definition-in-a-command","title":"Example of Field Definition in a Command","text":"<pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Example command using options and arguments\"\n\n    # Positional argument (for example, the first argument after the command name)\n    filename = command.Field(\n        pos=1,\n        help=\"Name of the file to process\",\n        default=\"default.txt\",  # default value if not specified\n    )\n\n    # Option activated with a flag (for example, -v for verbose)\n    verbose = command.Field(\n        pos=False,\n        help=\"Detailed mode\",\n        default=False,\n        alias=[\"v\"],\n    )\n\n    # Option expecting a value (for example, --level=3)\n    level = command.Field(\n        pos=False,\n        help=\"Level of detail\",\n        default=1,\n        alias=[\"l\"],\n        force_type=int,\n    )\n\n    def run(self):\n        out.info(f\"File: {self.filename}\")\n        out.info(f\"Verbose: {self.verbose}\")\n        out.info(f\"Level: {self.level}\")\n</code></pre> <p>In this example: - <code>filename</code> is a positional argument: the first value not associated with an option is assigned. - <code>verbose</code> is a boolean option: it is activated with <code>-v</code> or <code>--verbose</code>. - <code>level</code> is an option expecting a numerical value; it can be used as <code>--level=3</code> or <code>-l 3</code>.</p>"},{"location":"en/en/user-guide/options-arguments/#parsing-and-conversion-process","title":"Parsing and Conversion Process","text":"<p>When a command is executed: 1. Parsing:    CliFire reads the command line and separates the arguments and options using <code>shlex.split()</code>.    Positional arguments are assigned according to the order defined in the command\u2019s <code>_argument_names</code> property.</p> <ol> <li>Value Conversion:    Each field uses its <code>convert</code> method to transform the received string into its expected type.    For example:</li> <li>If the field <code>level</code> is defined with <code>force_type=int</code>, the string will be converted to an integer.</li> <li> <p>If the field is of type <code>list</code>, comma separation can be used to obtain a list of elements.</p> </li> <li> <p>Validations:</p> </li> <li>If a field is mandatory (without a default value), it is checked that a value has been provided.</li> <li>Options can have aliases; these are normalized (for example, by removing dashes and replacing <code>-</code> with <code>_</code>) to avoid duplicates.</li> </ol>"},{"location":"en/en/user-guide/options-arguments/#running-a-command-with-options-and-arguments","title":"Running a Command with Options and Arguments","text":"<p>When executing the above command from the terminal, you might experience different behaviors:</p> <pre><code>$ fire test myfile.txt -v --level=5\n</code></pre> <ul> <li>The value <code>\"myfile.txt\"</code> will be assigned to <code>filename</code>.</li> <li>The <code>-v</code> option sets <code>verbose</code> to <code>True</code>.</li> <li>The argument <code>--level=5</code> will be converted to an integer (<code>5</code>) and assigned to <code>level</code>.</li> </ul> <p>If some values are not provided, the default values defined will be used.</p>"},{"location":"en/en/user-guide/options-arguments/#conclusion","title":"Conclusion","text":"<p>Thanks to this flexible structure, CliFire makes it easy to define how data is received and processed in your commands. You can combine positional arguments and options with aliases, validations, and automatic type conversion, which simplifies the construction of robust and easy-to-use command line interfaces.</p> <p>Experiment by creating your own commands and adjusting the options according to your application\u2019s needs!</p>"},{"location":"en/en/user-guide/output/","title":"The <code>out</code> Module: Output and Styling","text":"<p>The <code>out</code> module in CliFire simplifies printing messages to the terminal in various styles and colors by harnessing the power of the Rich library. With these functions, you can display information, warnings, errors, success messages, debug outputs, and even live updates.</p>"},{"location":"en/en/user-guide/output/#main-functions","title":"Main Functions","text":"<p>Import the <code>out</code> module into your application as follows:</p> <pre><code>from clifire import out\n</code></pre> <p>Below are the most commonly used functions:</p> <ul> <li> <p><code>out.info(text: str) -&gt; None</code>   Displays an informational message.   <pre><code>out.info(\"This is an informational message\")\n</code></pre></p> </li> <li> <p><code>out.success(text: str) -&gt; None</code>   Displays a success message, perfect for indicating that an operation completed successfully.   <pre><code>out.success(\"Operation completed successfully\")\n</code></pre></p> </li> <li> <p><code>out.warn(text: str) -&gt; None</code>   Prints a warning message, useful when caution is required during execution.   <pre><code>out.warn(\"Warning: check your configuration\")\n</code></pre></p> </li> <li> <p><code>out.error(text: str) -&gt; None</code>   Displays an error message prominently to signal critical failures in the process.   <pre><code>out.error(\"Critical error occurred\")\n</code></pre></p> </li> <li> <p><code>out.debug(text: str) -&gt; None</code>   Prints debug messages, which are useful during development to trace internal behavior.   <pre><code>out.debug(\"Debug: variable x = 42\")\n</code></pre></p> </li> <li> <p><code>out.var_dump(var) -&gt; None</code>   Prints the contents of a variable in a human-readable format, highlighting its structure to aid in inspection.   <pre><code>sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\nout.var_dump(sample_dict)\n</code></pre></p> </li> <li> <p><code>out.LiveText</code>   This is a class that allows you to update text in real time in the terminal. It is useful for displaying progress bars or counters that update dynamically.   <pre><code>live_text = out.LiveText(\"Starting...\")\nlive_text.info(\"Process running\")\nlive_text.warn(\"Retrying operation\")\nlive_text.success(\"Operation completed\", end=False)\n</code></pre></p> </li> </ul>"},{"location":"en/en/user-guide/output/#general-usage","title":"General Usage","text":"<p>The <code>out</code> module is designed to integrate seamlessly with your commands and applications built with CliFire, providing a standardized and stylized output format for the terminal. Each function applies predefined styles to ensure a consistent and appealing user experience.</p> <p>Below is a complete example:</p> <pre><code>import time\n\nfrom clifire import application, command, out\n\n\nclass OutCommand(command.Command):\n    _name = 'out'\n\n    def fire(self):\n        print('Text colors')\n        print('-' * 80)\n        out.info(\"This is an informational message\")\n        out.success(\"Operation completed successfully\")\n        out.warn(\"Warning: check your configuration\")\n        out.error(\"Critical error occurred\")\n\n        print('')\n        print('Debug')\n        print('-' * 80)\n        out.debug(\"Debug: variable x = 42\")\n        sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\n        out.var_dump(sample_dict)\n\n        print('')\n        print('Tables')\n        print('-' * 80)\n        data = [\n            {\"name\": \"Luke\", \"age\": 18, \"is_student\": True},\n            {\"name\": \"Elizabeth\", \"age\": 101, \"is_student\": False},\n        ]\n        out.table(data, border=True, title=\"Contacts\")\n\n        print('')\n        print('Live text')\n        print('-' * 80)\n        live_text = out.LiveText(\"Starting...\")\n        time.sleep(1)\n        live_text.info(\"Process running\")\n        time.sleep(1)\n        live_text.warn(\"Retrying operation\")\n        time.sleep(1)\n        live_text.success(\"Operation completed\", end=False)\n        time.sleep(1)\n\n\ndef main():\n    app = application.App()\n    app.add_command(OutCommand)\n    app.fire(\"out -v\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p>"},{"location":"en/en/user-guide/output/#customization","title":"Customization","text":"<p>The <code>out</code> module uses a Rich Console object (<code>out.CONSOLE</code>) which can be customized. If you need to change the styles or modify the visual behavior, you can configure this object or refer to the Rich documentation for more options.</p> <p>With this guide, you will have an overview of how to use the <code>out</code> module to enhance the presentation of messages in your CLI applications built with CliFire.</p>"},{"location":"en/en/user-guide/templates/","title":"Templates in CliFire","text":"<p>The <code>Template</code> module in CliFire allows you to render and save files using templates based on Jinja2. This functionality helps you generate dynamic content easily, making it ideal for creating configuration files, reports, or other documents that require customization.</p> <p>You can use the <code>Template</code> module independently, or you can use it within the <code>App</code> class to manage your CLI application's configuration.</p> <p>The file <code>sample_template/hello.jinja2</code> is an example of a template that can be used with the <code>Template</code> module. Here is an example of what the template content might look like:</p> <pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;ul&gt;\n    {% for number in numbers %}\n        &lt;li&gt;{{ number }}&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n</code></pre> <p>The CLI command will be called <code>app_template.py</code> and will look like this: <pre><code>from clifire import application, command, out\n\n\nclass HelloCommand(command.Command):\n    _name = \"hello\"\n    _help = \"Create template\"\n\n    title = command.Field(\n        pos=1,\n        force_type=str,\n    )\n\n    def fire(self):\n        print(self.title)\n        content = self.app.template.render(\n            'hello.jinja2', title=self.title, numbers=[1, 2, 3])\n        out.success(content)\n\n\ndef main():\n    app = application.App(template_folder=\"./sample_template\")\n    app.add_command(HelloCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Running this command will render the <code>hello.jinja2</code> template with the given title and a list of numbers, displaying the result in the terminal.</p> <p></p>"},{"location":"en/en/user-guide/templates/#main-functions","title":"Main Functions","text":"<ul> <li><code>Template.render(template: str, **args) -&gt; str</code>   Renders a specified template. It receives the template file name and additional parameters that will be used to substitute the variables defined in the template.</li> </ul> <p>Example:   <pre><code>from clifire import template\n\n# Create the Template object by specifying the folder where the templates are located.\ntpl = template.Template(\"templates\")\ncontent = tpl.render(\"sample.jinja2\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n\n# 'content' will contain the HTML generated with the provided values.\nprint(content)\n</code></pre></p> <ul> <li><code>Template.write(template: str, filename: str, mark: Optional[str] = None, **args) -&gt; str</code>   Renders the template and saves its content to a file.   If a <code>mark</code> parameter is specified, the rendered content will be inserted or replaced between special markers in the file; this is useful for updating specific sections without overwriting the rest of the content.</li> </ul> <p>Example without a marker:   <pre><code>tpl = template.Template(\"templates\")\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p> <p>Example with a marker:   <pre><code>tpl = template.Template(\"templates\")\n# The marker '&lt;&lt;CONTENT&gt;&gt;' will delimit the section to update.\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p>"},{"location":"en/en/user-guide/templates/#how-it-works","title":"How It Works","text":"<ol> <li> <p>Template Rendering:    The <code>render</code> method loads the template file using Jinja2 and processes it with the provided arguments. This allows you to generate dynamic content based on variables defined in your template.</p> </li> <li> <p>Saving and Updating Files:    With the <code>write</code> method, you can directly save the rendered content to a file.    If you specify a <code>mark</code>:</p> </li> <li>The method searches within the file for the section delimited by that marker.</li> <li>If it finds the section, it replaces it with the new rendered content.</li> <li> <p>If it does not exist, it appends the section at the end of the file.    This enables you to update specific parts of the file without losing the original content that lies outside of the markers.</p> </li> <li> <p>Dynamic Integration:    The <code>Template</code> object integrates with the rest of CliFire, allowing you to utilize environment variables or any other business logic during rendering.</p> </li> </ol>"},{"location":"en/en/user-guide/templates/#complete-example","title":"Complete Example","text":"<pre><code>from clifire import template\n\ndef generate_report():\n    # Initialize the template by specifying the template folder\n    tpl = template.Template(\"templates\")\n\n    # Render the sample.jinja2 template with dynamic data\n    content = tpl.render(\"sample.jinja2\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n    print(\"Rendered Content:\")\n    print(content)\n\n    # Save the rendered content to output.html without using markers\n    tpl.write(\"sample.jinja2\", \"output.html\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\n    # Save the content to output_marked.html using a marker to update only a section\n    tpl.write(\"sample.jinja2\", \"output_marked.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\nif __name__ == \"__main__\":\n    generate_report()\n</code></pre>"},{"location":"en/en/user-guide/templates/#conclusion","title":"Conclusion","text":"<p>The <code>Template</code> module allows you to separate content logic from presentation, making it easier to generate dynamic files from templates. This improves the maintainability and flexibility of your CLI applications, as you can update specific sections of a file without affecting the rest of the content.</p> <p>This functionality is especially useful for projects that require periodic creation or updating of reports, configuration files, or any other type of document based on templates.</p>"},{"location":"en/es/","title":"CliFire","text":"<p>Minimal CLI framework to build Python commands quickly and elegantly.</p> <p>CliFire es una biblioteca ligera dise\u00f1ada para simplificar la creaci\u00f3n de interfaces de l\u00ednea de comandos (CLI). Permite a los desarrolladores definir comandos, opciones y argumentos de manera sencilla, facilitando la construcci\u00f3n de aplicaciones CLI complejas sin la sobrecarga de frameworks m\u00e1s grandes.</p> <p>La idea de CliFire es que puedas crear CLI (Command Line Interface) de forma r\u00e1pida y sencilla, aprovechando las caracter\u00edsticas de Python. Su enfoque minimalista y su sintaxis intuitiva hacen que sea f\u00e1cil de aprender y usar, permitiendo a los desarrolladores centrarse en la l\u00f3gica de sus aplicaciones en lugar de en la infraestructura de la CLI.</p> <p>Adem\u00e1s con el comando <code>fire</code> se pueden crear comandos din\u00e1micos directamente desde la terminal, lo que permite una experiencia interactiva y flexible.</p>"},{"location":"en/es/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Dos estilos de uso: decoradores para un enfoque simple o clases para mayor personalizaci\u00f3n</li> <li>Sintaxis intuitiva: enfocada en la simplicidad y legibilidad</li> <li>Opciones globales y por comando: configuraci\u00f3n flexible de par\u00e1metros</li> <li>Comandos agrupados: organiza comandos relacionados jer\u00e1rquicamente</li> <li>Salidas con formato: utiliza Rich para mostrar mensajes con colores y estilos</li> <li>Plantillas integradas: crea archivos con Jinja2</li> <li>Configuraci\u00f3n centralizada: gestiona la configuraci\u00f3n de tu aplicaci\u00f3n f\u00e1cilmente</li> </ul>"},{"location":"en/es/#instalacion-rapida","title":"Instalaci\u00f3n r\u00e1pida","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"en/es/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"en/es/changelog/#011-2025-06-07","title":"[0.1.1] - 2025-06-07","text":""},{"location":"en/es/changelog/#added","title":"Added","text":"<ul> <li>Bash command <code>clifire</code>  for creating dynamic commands.</li> <li>In application module, added:</li> <li>Global option <code>--verbose</code> created by default.</li> <li>If no command is passed, help is shown if the help command is defined.</li> <li>New <code>path</code> method for get absolute path to a filename.</li> <li>New <code>config</code> variable for managing configuration settings.</li> <li>New <code>template</code> variable for creating files with jinja2.</li> <li>In out module, added:</li> <li><code>debug</code> method for printing debug messages.</li> <li><code>debug2</code> method for printing debug messages level 2.</li> <li><code>var_dump</code> method for printing pretty variables in out module.</li> <li>New <code>Config</code> class to manage configuration settings.</li> <li>New <code>Template</code> class for creating files with jinja2.</li> <li>Changed relative imports to module imports for better compatibility.</li> </ul>"},{"location":"en/es/changelog/#changed","title":"Changed","text":"<ul> <li>Commands now use <code>fire()</code> method instead of <code>run()</code>.</li> <li>Compatibility with Python 3.10.</li> <li>Updated documentation to include usage examples for the new <code>clifire</code> command.</li> <li>Enhanced the <code>--verbose</code> option to provide more detailed output during command execution.</li> <li>Improved Result class, stdout and stderr are now str instead of list</li> </ul>"},{"location":"en/es/changelog/#fixed","title":"Fixed","text":"<ul> <li>The arguments between quotes are now correctly parsed, allowing for spaces in arguments.</li> <li>The [options] message in <code>help</code> command not correctly displayed.</li> </ul>"},{"location":"en/es/changelog/#removed","title":"Removed","text":""},{"location":"en/es/changelog/#010-2025-06-01","title":"[0.1.0] - 2025-06-01","text":""},{"location":"en/es/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release with the first usable version.</li> </ul>"},{"location":"en/es/contributing/","title":"Contribuir a CliFire","text":"<p>\u00a1Gracias por tu inter\u00e9s en contribuir a CliFire!</p> <p>Las contribuciones son bienvenidas y ayudan a mejorar este proyecto minimalista para construir aplicaciones CLI en Python.</p>"},{"location":"en/es/contributing/#como-contribuir","title":"\u00bfC\u00f3mo Contribuir?","text":"<p>Existen varias maneras de ayudar:</p> <ul> <li>Reportando errores: Si encuentras un bug o comportamiento inesperado, por favor abre un issue en GitHub con una descripci\u00f3n detallada y, si es posible, pasos para reproducirlo.</li> <li>Solicitando nuevas funcionalidades: Si tienes una idea para mejorar CliFire, abre un issue o propone un pull request.</li> <li>C\u00f3digo y mejoras: Si deseas enviar c\u00f3digo, aseg\u00farate de seguir las pautas de estilo y a\u00f1ade pruebas unitarias para respaldar tus cambios.</li> <li>Documentaci\u00f3n: Ayuda a mejorar la documentaci\u00f3n, ya sea corrigiendo errores, ampliando secciones o a\u00f1adiendo ejemplos de uso.</li> </ul>"},{"location":"en/es/contributing/#flujo-de-contribucion","title":"Flujo de Contribuci\u00f3n","text":""},{"location":"en/es/contributing/#fork-del-repositorio","title":"Fork del repositorio","text":"<p>Haz un fork del proyecto en GitHub.</p>"},{"location":"en/es/contributing/#clona-tu-fork-en-local","title":"Clona tu fork en local:","text":"<pre><code>git clone https://github.com/your-user/clifire.git\ncd clifire\n</code></pre>"},{"location":"en/es/contributing/#crea-una-rama-para-tus-cambios","title":"Crea una rama para tus cambios:","text":"<pre><code>git checkout -b my-changes\n</code></pre>"},{"location":"en/es/contributing/#realiza-tus-cambios","title":"Realiza tus cambios:","text":"<p>Realiza los cambios necesarios en el c\u00f3digo. Aseg\u00farate de que:</p> <ul> <li>Sigue las convenciones de estilo del proyecto.</li> <li>A\u00f1ade pruebas unitarias, el proyecto tiene el 100% de coverage!.</li> <li>Actualiza o a\u00f1ade documentaci\u00f3n si fuera necesario.</li> </ul>"},{"location":"en/es/contributing/#ejecuta-los-tests","title":"Ejecuta los tests:","text":"<p>Aseg\u00farate de que todos los tests pasan con:    <pre><code>poetry run pytest\n</code></pre>    Comprueba la cobertura:    <pre><code>poetry run coverage run -m pytest &amp;&amp; poetry run coverage html\n</code></pre></p> <p>Tambi\u00e9n puedes usar <code>poetry run fire coverage</code> para ejecutar los tests y generar el informe de cobertura.</p>"},{"location":"en/es/contributing/#realiza-un-pull-request","title":"Realiza un Pull Request:","text":"<p>Una vez que est\u00e9s satisfecho con tus cambios, realiza un pull request a la rama principal del repositorio. Describe detalladamente lo que has cambiado y la motivaci\u00f3n detr\u00e1s de ello.</p>"},{"location":"en/es/contributing/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ul> <li>Escribe mensajes de commit claros y descriptivos.</li> <li>Sigue el formato de Keep a Changelog para documentar tus cambios.</li> <li>Aseg\u00farate de que las nuevas funcionalidades o arreglos no rompan la compatibilidad existente.</li> <li>Respeta el formato y la estructura de la documentaci\u00f3n existente.</li> </ul>"},{"location":"en/es/contributing/#revision-y-feedback","title":"Revisi\u00f3n y Feedback","text":"<p>Tu pull request ser\u00e1 revisado por mantenedores del proyecto. Es posible que te pidan ajustes o aclaraciones, \u00a1as\u00ed que estate atento a los comentarios!</p> <p>Para m\u00e1s detalles, consulta la Gu\u00eda de Contribuci\u00f3n Completa en el repositorio.</p> <p>\u00a1Gracias por ayudar a que CliFire crezca y mejore!</p>"},{"location":"en/es/quick-start/","title":"Gu\u00eda R\u00e1pida - Empezando con CliFire","text":"<p>Bienvenido a la gu\u00eda r\u00e1pida de CliFire, un framework minimalista para crear interfaces de l\u00ednea de comandos en Python de forma sencilla y elegante.</p>"},{"location":"en/es/quick-start/#instalacion","title":"Instalaci\u00f3n","text":"<p>Puedes instalar CliFire desde PyPI o directamente usando Poetry:</p>"},{"location":"en/es/quick-start/#desde-pypi","title":"Desde PyPI","text":"<pre><code>pip install clifire\n</code></pre>"},{"location":"en/es/quick-start/#usando-poetry","title":"Usando Poetry","text":"<pre><code>poetry add clifire\n</code></pre>"},{"location":"en/es/quick-start/#uso-basico","title":"Uso B\u00e1sico","text":"<p>CliFire te permite definir comandos mediante decoradores o clases. Aqu\u00ed tienes un ejemplo utilizando un decorador para saludar al usuario:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre>"},{"location":"en/es/quick-start/#ejecutando-el-comando","title":"Ejecutando el Comando","text":"<p>Guarda el archivo como <code>fire.py</code> o crea un directorio <code>fire</code> y coloca el archivo dentro con extensi\u00f3n <code>.py</code>.</p> <p>La ayuda se construye autom\u00e1ticamente a partir del docstring, lo que permite a los usuarios entender r\u00e1pidamente c\u00f3mo usar el comando:</p> <p></p> <p>Puedes ejecutar el comando <code>greet</code> directamente: </p>"},{"location":"en/es/quick-start/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Definici\u00f3n Sencilla de Comandos: Usa decoradores o clases para crear comandos din\u00e1micos.</li> <li>Manejo de Argumentos y Opciones: Define argumentos y opciones para personalizar el comportamiento de tus comandos.</li> <li>Salida formateada: Utiliza el m\u00f3dulo <code>out</code> para mostrar mensajes con estilos y colores usando la libreria <code>Rich</code>.</li> <li>Configuraci\u00f3n centralizada: Administra la configuraci\u00f3n de tu aplicaci\u00f3n mediante la clase <code>Config</code>.</li> <li>Plantillas de ficheros: Crea archivos con plantillas Jinja2 usando la clase <code>Template</code>.</li> </ul>"},{"location":"en/es/quick-start/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Para m\u00e1s detalles sobre la API y configuraci\u00f3n, consulta la Documentaci\u00f3n de Usuario.</li> <li>Revisa la API Reference para ver todas las funciones y clases disponibles.</li> <li>Mira ejemplos pr\u00e1cticos en la secci\u00f3n Ejemplos.</li> </ul> <p>\u00a1Empieza a crear tus comandos y disfruta de una experiencia minimalista y potente con CliFire!</p>"},{"location":"en/es/user-guide/basics/","title":"Conceptos B\u00e1sicos de CliFire","text":"<p>CliFire es un framework minimalista para crear aplicaciones de l\u00ednea de comandos en Python de forma sencilla y elegante. Esta gu\u00eda te introduce en los conceptos fundamentales para que puedas empezar a utilizarlo r\u00e1pidamente.</p> <p>Tenemos dos sabores para usar CliFire, por decoradores o por clases:</p> <ul> <li>Decoradores: Permiten definir comandos de forma r\u00e1pida y sencilla, sin perder potencia ni flexibilidad.</li> <li>Clases: Ofrecen un control m\u00e1s detallado sobre el comportamiento de los comandos, ideal para aplicaciones m\u00e1s complejas.</li> </ul> <p>La idea de CliFire es que puedas crear aplicaciones CLI (Command Line Interface) de forma r\u00e1pida y sencilla, aprovechando las caracter\u00edsticas de Python.</p>"},{"location":"en/es/user-guide/basics/#1-comandos","title":"1. Comandos","text":"<p>Los comandos son la esencia de tu aplicaci\u00f3n CLI. Puedes definirlos de dos formas:</p> <ul> <li>Usando decoradores:   Se facilita la creaci\u00f3n de comandos con el decorador <code>@command.fire</code>.</li> </ul> <pre><code>from clifire import command, out\n\n@command.fire\ndef hello(cmd, name: str = \"World\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user. Defaults to \"World\".\n    \"\"\"\n    out.info(f\"Hello, {name}!\")\n</code></pre> <ul> <li>Usando clases:   Crear una clase que herede de <code>command.Command</code> para tener mayor control sobre el comportamiento del comando.</li> </ul> <pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    def fire(self):\n        out.info(\"Executing test command\")\n</code></pre>"},{"location":"en/es/user-guide/basics/#2-opciones-y-argumentos","title":"2. Opciones y Argumentos","text":"<p>CliFire te permite definir:</p> <ul> <li>Opciones Globales: Configuraciones que afectan a toda la aplicaci\u00f3n (por ejemplo, el modo verbose).</li> <li>Opciones Locales: Argumentos y opciones espec\u00edficos para cada comando.</li> </ul> <p>Estas opciones se pueden establecer con la clase <code>Field</code> del m\u00f3dulo <code>command</code>.</p> <pre><code>from clifire import command\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Test command\"\n\n    bool_option = command.Field(\n        pos=1,\n        help=\"Example boolean option\",\n        default=False,\n        alias=[\"-v\"],\n    )\n\n    def fire(self):\n        if self.bool_option:\n            print(\"Verbose option enabled\")\n        else:\n            print(\"Verbose option disabled\")\n</code></pre>"},{"location":"en/es/user-guide/basics/#3-configuracion","title":"3. Configuraci\u00f3n","text":"<p>La clase <code>Config</code> gestiona la configuraci\u00f3n de tu aplicaci\u00f3n. Permite leer datos de ficheros YAML y escribirlos, excluyendo campos privados (aquellos que comienzan con <code>_</code>).</p> <pre><code>from clifire import config\n\nconf = config.Config(config_file=\"config.yaml\")\nconf.name = \"MyApp\"\nconf.version = \"1.0.0\"\nconf.write()\n</code></pre> <p>Nota: Los campos privados (por ejemplo, <code>_secret</code>) no se guardan en el fichero de configuraci\u00f3n.</p>"},{"location":"en/es/user-guide/basics/#4-salida-y-estilos","title":"4. Salida y Estilos","text":"<p>El m\u00f3dulo <code>out</code> utiliza la biblioteca Rich para mostrar mensajes con distintos estilos y colores:</p> <ul> <li><code>out.info()</code>: Informaci\u00f3n.</li> <li><code>out.success()</code>: \u00c9xito.</li> <li><code>out.warn()</code>: Advertencia.</li> <li><code>out.error()</code>: Error.</li> </ul> <pre><code>from clifire import out\n\nout.info(\"This is an informational message\")\n</code></pre>"},{"location":"en/es/user-guide/basics/#5-plantillas","title":"5. Plantillas","text":"<p>La clase <code>Template</code> te permite generar archivos a partir de plantillas Jinja2. Esto es \u00fatil para crear ficheros con contenido din\u00e1mico de forma sencilla.</p> <pre><code>from clifire import template\n\ntpl = template.Template(template_folder=\"templates\")\ncontent = tpl.render(\n    \"sample.jinja2\",\n    title=\"My Title\",\n    user=\"admin\",\n    items=[\"data1\", \"data2\"]\n)\n</code></pre> <p>Adem\u00e1s, la funci\u00f3n <code>write</code> de la plantilla permite guardar el contenido renderizado en un fichero, con la opci\u00f3n de insertar o reemplazar contenido delimitado por marcas.</p> <p>Esto es \u00fatil para generar archivos de configuraci\u00f3n o scripts personalizados que se pueden actualizar f\u00e1cilmente en el futuro sin afectar al resto del contenido del archivo.</p>"},{"location":"en/es/user-guide/basics/#6-flujo-de-ejecucion","title":"6. Flujo de Ejecuci\u00f3n","text":"<ol> <li> <p>Definici\u00f3n de Comandos:    Se definen mediante decoradores o clases.</p> </li> <li> <p>Registro de Comandos:    Al instanciar <code>App</code> se registran los comandos. Por defecto, se a\u00f1ade un comando de ayuda que muestra la informaci\u00f3n de todos los comandos disponibles.</p> </li> <li> <p>Parseo y Ejecuci\u00f3n:    Al lanzar la aplicaci\u00f3n se analiza la l\u00ednea de comandos, se identifica el comando a ejecutar y se procesan sus opciones y argumentos.</p> </li> </ol>"},{"location":"en/es/user-guide/basics/#conclusion","title":"Conclusi\u00f3n","text":"<p>Con estos conceptos b\u00e1sicos, ya est\u00e1s listo para empezar a usar CliFire en tus proyectos. La simplicidad y flexibilidad de este framework te permitir\u00e1n construir aplicaciones CLI potentes y personalizadas sin complicaciones.</p> <p>Para m\u00e1s detalles y ejemplos avanzados revisa la Gu\u00eda de Usuario y la API Reference.</p>"},{"location":"en/es/user-guide/classes/","title":"Comandos Basados en Clases","text":"<p>Adem\u00e1s de usar decoradores, CliFire permite definir comandos mediante clases. Este enfoque es \u00fatil cuando necesitas mayor personalizaci\u00f3n o l\u00f3gica compleja en tus comandos.</p>"},{"location":"en/es/user-guide/classes/#definiendo-un-comando-con-clases","title":"Definiendo un Comando con Clases","text":"<p>Para crear un comando basado en clases, hereda de <code>command.Command</code> y establece las siguientes propiedades:</p> <ul> <li><code>_name</code>: Nombre del comando. Si deseas agrupar comandos, usa puntos (por ejemplo, <code>db.create</code>).</li> <li><code>_help</code>: Descripci\u00f3n breve que se mostrar\u00e1 en la ayuda.</li> <li>Campos/Argumentos: Define los argumentos y opciones como atributos de la clase utilizando <code>command.Field</code>.</li> </ul> <p>Ejemplo b\u00e1sico:</p> <pre><code>from clifire import command, out\n\nclass CommandGreet(command.Command):\n    _name = \"greet\"\n    _help = \"Greets the user in a personalized way\"\n\n    # Define a field for the name (non-option argument)\n    name = command.Field(\n        pos=1,\n        help=\"User's name\",\n        default=\"World\",\n        alias=[],\n    )\n\n    # Define a field to enable informal greeting (option)\n    informal = command.Field(\n        pos=None,\n        help=\"Use informal greeting\",\n        default=False,\n        alias=[\"-i\"],\n    )\n\n    def fire(self):\n        if self.informal:\n            out.info(f\"Hello, {self.name}! How's it going?\")\n        else:\n            out.info(f\"Good morning, {self.name}!\")\n</code></pre>"},{"location":"en/es/user-guide/classes/#registro-y-ejecucion","title":"Registro y Ejecuci\u00f3n","text":"<p>Al instanciar la aplicaci\u00f3n, el comando se registra y se puede ejecutar desde la l\u00ednea de comandos:</p> <pre><code>$ fire greet\nGood morning, World!\n\n$ fire greet Alice -i\nHello, Alice! How's it going?\n</code></pre>"},{"location":"en/es/user-guide/classes/#ventajas-del-enfoque-basado-en-clases","title":"Ventajas del Enfoque basado en Clases","text":"<ul> <li>Mayor control y personalizaci\u00f3n: Puedes definir m\u00e9todos y atributos propios para manejar casos de uso complejos.</li> <li>Herencia: Puedes crear comandos base y extenderlos para compartir comportamientos comunes.</li> <li>Organizaci\u00f3n: Resultado en una estructura clara y modular cuando se tiene una gran cantidad de comandos.</li> </ul>"},{"location":"en/es/user-guide/classes/#detalles-internos","title":"Detalles Internos","text":"<p>Cuando se instancia la aplicaci\u00f3n, se registran los comandos definidos como clases. La aplicaci\u00f3n llama al m\u00e9todo <code>fire()</code> del comando correspondiente, luego de haber parseado los argumentos y opciones. Adem\u00e1s:</p> <ul> <li>Los campos se actualizan autom\u00e1ticamente desde el parseo del comando.</li> <li>Los alias y conversiones de tipos se gestionan en la clase <code>Field</code> (ver command.py).</li> </ul> <p>Con este mecanismo, puedes aprovechar al m\u00e1ximo la flexibilidad de Python y crear comandos con comportamientos avanzados sin complicar la sintaxis a nivel de funci\u00f3n.</p> <p>\u00a1Explora y experimenta creando tus propios comandos personalizados!</p>"},{"location":"en/es/user-guide/config/","title":"Configuration (Configuraci\u00f3n)","text":"<p>El m\u00f3dulo <code>Config</code> de CliFire se encarga de gestionar la configuraci\u00f3n de la aplicaci\u00f3n a trav\u00e9s de archivos YAML. Permite leer y escribir la configuraci\u00f3n, asegur\u00e1ndose de excluir autom\u00e1ticamente los campos privados (aquellos cuyo nombre comienza con <code>_</code>).</p>"},{"location":"en/es/user-guide/config/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li> <p>Exclusi\u00f3n autom\u00e1tica de campos privados:   Cuando se escribe la configuraci\u00f3n, se excluyen las propiedades cuyo nombre inicia con <code>_</code>, asegurando que la informaci\u00f3n sensible o interna no se almacene en el archivo.</p> </li> <li> <p>Carga flexible de archivos de configuraci\u00f3n:   El m\u00e9todo de clase <code>get_config</code> permite especificar una lista de posibles archivos de configuraci\u00f3n. Se carga el primer archivo existente o, si ninguno existe, se puede crear uno si se indica con la opci\u00f3n <code>create</code>.</p> </li> <li> <p>Gesti\u00f3n din\u00e1mica de atributos:   Los valores de configuraci\u00f3n se asignan como atributos de la instancia de <code>Config</code>, permitiendo acceder a ellos de forma din\u00e1mica mediante el m\u00e9todo <code>get</code>.</p> </li> </ul>"},{"location":"en/es/user-guide/config/#ejemplo-de-uso","title":"Ejemplo de Uso","text":"<p>Puede usar el m\u00f3dulo <code>Config</code> de manera independiente, o puede usarlo dentro de la clase <code>App</code> para manejar la configuraci\u00f3n de su aplicaci\u00f3n CLI.</p> <pre><code>from clifire import application, command, out\n\n\nclass ConfigCommand(command.Command):\n    _name = \"config\"\n    _help = \"Show config vars\"\n\n    def fire(self):\n        self.app.config.my_new_var = \"My new var\"\n        out.var_dump(self.app.config)\n\n\ndef main():\n    app = application.App(config_files=[\"~/.myapp.yml\"], config_create=True)\n    app.add_command(ConfigCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Ahora podemos ejecutarlo</p> <p></p>"},{"location":"en/es/user-guide/config/#leer-la-configuracion","title":"Leer la Configuraci\u00f3n","text":"<p>Para cargar la configuraci\u00f3n de la aplicaci\u00f3n, utiliza el m\u00e9todo <code>get_config</code>. Por ejemplo:</p> <pre><code>from clifire import config\n\n# Attempt to load configuration from 'config.yaml' or 'default.yaml'\ncfg = config.Config.get_config([\"config.yaml\", \"default.yaml\"])\nif not cfg.read():\n    print(\"Configuration file not found.\")\nelse:\n    print(\"Configuration loaded successfully.\")\n    print(\"Application Name:\", cfg.get(\"name\"))\n</code></pre> <p>En este ejemplo, si el archivo de configuraci\u00f3n existe, se actualizan los atributos de la instancia <code>cfg</code>. Si no, <code>read()</code> retorna <code>False</code>.</p>"},{"location":"en/es/user-guide/config/#escribir-la-configuracion","title":"Escribir la Configuraci\u00f3n","text":"<p>Para guardar la configuraci\u00f3n actual en un archivo, utiliza el m\u00e9todo <code>write()</code>. Observa c\u00f3mo se excluyen los campos privados:</p> <pre><code>from clifire import config\n\ncfg = config.Config(config_file=\"config.yaml\")\ncfg.name = \"MyApp\"\ncfg.version = \"1.0.0\"\ncfg._secret_key = \"my-secret-key\"  # This will not be saved\ncfg.write()\n</code></pre> <p>Exclusi\u00f3n de Campos Privados</p> <p>Todas las variables que comienzan con <code>_</code> no se guardar\u00e1n en el archivo YAML. Esto es \u00fatil para mantener la privacidad de los datos sensibles o internos de la aplicaci\u00f3n.</p>"},{"location":"en/es/user-guide/config/#resumen","title":"Resumen","text":"<p>El m\u00f3dulo <code>Config</code> proporciona una forma sencilla y segura de administrar la configuraci\u00f3n de tu aplicaci\u00f3n CLI mediante archivos YAML. Al leer y escribir la configuraci\u00f3n, se excluyen autom\u00e1ticamente los campos privados, lo que ayuda a mantener la seguridad y la limpieza de los datos almacenados.</p> <p>Esta funcionalidad robusta facilita la centralizaci\u00f3n y el manejo de la configuraci\u00f3n en CliFire, contribuyendo a la flexibilidad y mantenibilidad de tus aplicaciones.</p>"},{"location":"en/es/user-guide/decorators/","title":"Decoradores en CliFire","text":"<p>En CliFire, los decorators facilitan la creaci\u00f3n y registro de comandos de manera simple y elegante. Gracias al decorador <code>@command.fire</code> puedes transformar f\u00e1cilmente funciones regulares en comandos CLI.</p>"},{"location":"en/es/user-guide/decorators/#que-es-un-decorator","title":"\u00bfQu\u00e9 es un Decorator?","text":"<p>En Python, un decorator es una funci\u00f3n que recibe otra funci\u00f3n y la extiende o modifica sin alterar su estructura. En el contexto de CliFire, el decorador:</p> <ul> <li>Registra el comando en la aplicaci\u00f3n.</li> <li>Extrae informaci\u00f3n (nombre, argumentos, docstring) necesaria para el comando.</li> <li>Prepara la funci\u00f3n para invocarse desde la l\u00ednea de comandos.</li> </ul>"},{"location":"en/es/user-guide/decorators/#uso-del-decorador-commandfire","title":"Uso del Decorador <code>@command.fire</code>","text":"<p>El decorador <code>@command.fire</code> es la forma m\u00e1s sencilla de convertir una funci\u00f3n en un comando dentro de CliFire. Por ejemplo, creamos el fichero <code>fire/greet.py</code> con el siguiente contenido:</p> <pre><code>from clifire import command, out\n\n\n@command.fire\ndef greet(cmd, name: str = \"World\", _end_char: str = \"?\"):\n    \"\"\"\n    Greets the user.\n\n    Args:\n        name: Name of the user to greet. Defaults to \"World\".\n        _end_char: Character to use at the end of the greeting. Defaults to \"?\".\n    \"\"\"\n    result = cmd.app.shell(\"whoami\")\n    out.info(f\"System user: {result.stdout}\")\n    out.success(f\"Hello {name}{_end_char}\")\n</code></pre> <p>Al aplicar <code>@command.fire</code>:</p> <ul> <li>La funci\u00f3n <code>greet</code> se transforma en un objeto comando.</li> <li>Se extrae la informaci\u00f3n del nombre del comando y de los argumentos a partir del docstring.</li> <li>El comando queda registrado autom\u00e1ticamente para ser utilizado en la CLI.</li> </ul>"},{"location":"en/es/user-guide/decorators/#ventajas-de-usar-decorators","title":"Ventajas de Usar Decorators","text":"<ul> <li>Simplicidad: Define comandos con pocas l\u00edneas de c\u00f3digo.</li> <li>Organizaci\u00f3n: Separa la l\u00f3gica del comando de la configuraci\u00f3n de la interfaz CLI.</li> <li>Flexibilidad: Permite definir argumentos y opciones mediante anotaciones de tipos y comentarios en el docstring.</li> </ul>"},{"location":"en/es/user-guide/decorators/#registro-automatico-del-comando","title":"Registro Autom\u00e1tico del Comando","text":"<p>Cuando defines una funci\u00f3n con <code>@command.fire</code>, el decorador realiza las siguientes operaciones:</p> <ol> <li>Obtiene el nombre del comando utilizando <code>func.__name__</code> o un atributo personalizado.</li> <li>Procesa el docstring para extraer la descripci\u00f3n y detalles de cada argumento.</li> <li>Crea din\u00e1micamente una clase que hereda de <code>command.Command</code> y que representa el comando.</li> <li>Registra este comando en la aplicaci\u00f3n actual mediante <code>get_current_app().add_command(...)</code>.</li> </ol>"},{"location":"en/es/user-guide/decorators/#ejecucion-de-comandos","title":"Ejecuci\u00f3n de Comandos","text":"<p>La ayuda se construye autom\u00e1ticamente a partir del docstring, lo que permite a los usuarios entender r\u00e1pidamente c\u00f3mo usar el comando:</p> <p></p> <p>Puedes ejecutar el comando <code>greet</code> directamente: </p>"},{"location":"en/es/user-guide/decorators/#el-comando-fire","title":"El comando <code>fire</code>","text":"<p>El comando <code>fire</code> es la entrada principal para interactuar con tu aplicaci\u00f3n CLI. Permite ejecutar comandos y pasarles argumentos y opciones.</p> <p><code>fire</code> busca tus comandos o en un fichero <code>fire.py</code> o en la carpeta <code>fire/*.py</code> del directorio donde se lanza.</p>"},{"location":"en/es/user-guide/decorators/#personalizacion","title":"Personalizaci\u00f3n","text":"<p>Si necesitas modificar el comportamiento de un comando: - Puedes ajustar las opciones y argumentos en el decorador. - Utiliza docstrings claros para definir la ayuda del comando. - Explora la implementaci\u00f3n de <code>@command.fire</code> en <code>clifire/command.py</code> para ver c\u00f3mo se procesa la informaci\u00f3n.</p> <p>Con este mecanismo basado en decoradores, CliFire te permite construir comandos de forma r\u00e1pida, manteniendo el c\u00f3digo limpio y organizado.</p> <p>\u00a1Empieza a usar decoradores para simplificar la creaci\u00f3n de tus comandos y aprovecha la flexibilidad que ofrece CliFire!</p>"},{"location":"en/es/user-guide/grouped-commands/","title":"Comandos Agrupados en CliFire","text":"<p>CliFire permite organizar los comandos en grupos utilizando una convenci\u00f3n de nomenclatura basada en puntos. Esto es especialmente \u00fatil cuando tu aplicaci\u00f3n CLI tiene muchas funcionalidades, ya que mejora la legibilidad y la organizaci\u00f3n.</p>"},{"location":"en/es/user-guide/grouped-commands/#como-funciona","title":"\u00bfC\u00f3mo funciona?","text":"<p>Para agrupar comandos, simplemente define el nombre del comando utilizando un punto (<code>.</code>) para separar el nombre del grupo y el comando espec\u00edfico. Por ejemplo, para agrupar comandos relacionados a la base de datos, puedes usar nombres como <code>db.create</code> y <code>db.drop</code>.</p> <p>Cuando se registra el comando, la funcionalidad de ayuda de CliFire (por ejemplo, en el comando de ayuda) detecta el car\u00e1cter <code>.</code> y agrupa autom\u00e1ticamente los comandos bajo el mismo grupo.</p>"},{"location":"en/es/user-guide/grouped-commands/#ejemplo-de-definicion-de-comandos-agrupados","title":"Ejemplo de definici\u00f3n de comandos agrupados","text":"<p>Quien define el grupo es la variable  <code>_name</code> de la clase <code>Command</code>, o el nombre del m\u00e9todo en los decoradores.</p> <p>Aqu\u00ed tienes un ejemplo de c\u00f3mo definir comandos agrupados utilizando clases: <pre><code>from clifire import command, out\n\nclass DbCreateCommand(command.Command):\n    _name = \"db.create\"\n    _help = \"Create the database\"\n\n    def run(self):\n        out.info(\"Database created.\")\n\nclass DbDropCommand(command.Command):\n    _name = \"db.drop\"\n    _help = \"Drop a database\"\n\n    def run(self):\n        out.info(\"Database removed.\")\n</code></pre></p>"},{"location":"en/es/user-guide/grouped-commands/#registro-y-ejecucion","title":"Registro y ejecuci\u00f3n","text":"<p>Registra los comandos en tu aplicaci\u00f3n:</p> <pre><code>from clifire import application\n\napp = application.App(name=\"MyApp CLI\", version=\"1.0\")\napp.add_command(CommandDbCreate)\napp.add_command(CommandDbDrop)\n</code></pre> <p>Luego, al ejecutar el comando de ayuda:</p> <pre><code>$ fire help\n</code></pre> <p>La salida mostrar\u00e1 los comandos agrupados, por ejemplo:</p> <pre><code>Available Commands:\n\n  db\n    create          Create the database\n    drop            Drop the database\n</code></pre>"},{"location":"en/es/user-guide/grouped-commands/#uso-de-los-comandos-agrupados-en-los-decoradores","title":"Uso de los comandos agrupados en los decoradores","text":"<p>Puedes usar la misma convenci\u00f3n de agrupaci\u00f3n con los decoradores para agrupar los comandos, en este caso, los grupos se obtienen del nombre del m\u00e9todo usando el car\u00e1cter <code>_</code>:</p> <pre><code>from clifire import command\n\n@command.fire\ndef db_create(cmd):\n    \"\"\"\n    Create the database\n    \"\"\"\n    out.info(\"Database created.\")\n\n@command.fire\ndef db_drop(cmd):\n    \"\"\"\n    Drop the database.\n    \"\"\"\n    out.info(\"Database removed.\")\n</code></pre>"},{"location":"en/es/user-guide/grouped-commands/#consejos-adicionales","title":"Consejos adicionales","text":"<ul> <li>Consistencia en los nombres: Aseg\u00farate de seguir una convenci\u00f3n coherente al nombrar tus comandos (por ejemplo, <code>grupo.comando</code>) para que el agrupamiento sea intuitivo.</li> <li>Subgrupos: Si lo necesitas, puedes definir m\u00e1s niveles de agrupaci\u00f3n utilizando m\u00e1s de un punto (por ejemplo, <code>db.table.create</code>).</li> <li>Personalizaci\u00f3n de la ayuda: Puedes extender la funcionalidad del comando de ayuda para modificar c\u00f3mo se muestran los grupos si fuera necesario.</li> </ul> <p>Con esta estructura, podr\u00e1s organizar tus comandos de forma clara y brindar una mejor experiencia a los usuarios de tu aplicaci\u00f3n CLI.</p>"},{"location":"en/es/user-guide/options-arguments/","title":"Opciones y Argumentos en CliFire","text":"<p>En CliFire, los comandos pueden recibir datos tanto como argumentos posicionados como opciones. Estos se definen mediante la clase <code>Field</code> en el m\u00f3dulo <code>command</code>.</p>"},{"location":"en/es/user-guide/options-arguments/#definicion-de-campos","title":"Definici\u00f3n de Campos","text":"<p>Cada campo que se declara como atributo en un comando se reconoce como:</p> <ul> <li> <p>Argumento Posicionado:   Si el campo tiene un valor de <code>pos</code> definido (por ejemplo, <code>pos=1</code>), se trata de un argumento que se espera en un orden determinado.   Los argumentos se asignan en base a su posici\u00f3n en la l\u00ednea de comandos.</p> </li> <li> <p>Opci\u00f3n:   Si <code>pos</code> es <code>False</code> o <code>None</code>, el campo se interpreta como una opci\u00f3n.   Estas se indican en la l\u00ednea de comandos con un gui\u00f3n simple o doble (por ejemplo, <code>-v</code> o <code>--verbose</code>).   Adem\u00e1s, se pueden definir alias para facilitar su uso.</p> </li> </ul>"},{"location":"en/es/user-guide/options-arguments/#ejemplo-de-definicion-en-un-comando","title":"Ejemplo de Definici\u00f3n en un Comando","text":"<pre><code>from clifire import command, out\n\nclass CommandTest(command.Command):\n    _name = \"test\"\n    _help = \"Example command using options and arguments\"\n\n    # Argumento posicionado (por ejemplo, el primer argumento luego del nombre del comando)\n    filename = command.Field(\n        pos=1,\n        help=\"Name of the file to process\",\n        default=\"default.txt\",  # default value if not specified\n    )\n\n    # Opci\u00f3n que se activa con bandeja (por ejemplo, -v para verbose)\n    verbose = command.Field(\n        pos=False,\n        help=\"Detailed mode\",\n        default=False,\n        alias=[\"v\"],\n    )\n\n    # Opci\u00f3n que espera un valor (por ejemplo, --level=3)\n    level = command.Field(\n        pos=False,\n        help=\"Level of detail\",\n        default=1,\n        alias=[\"l\"],\n        force_type=int,\n    )\n\n    def run(self):\n        out.info(f\"File: {self.filename}\")\n        out.info(f\"Verbose: {self.verbose}\")\n        out.info(f\"Level: {self.level}\")\n</code></pre> <p>En este ejemplo: - <code>filename</code> es un argumento posicionado: se asigna el primer valor no asociado a una opci\u00f3n. - <code>verbose</code> es una opci\u00f3n booleana: se activa con <code>-v</code> o <code>--verbose</code>. - <code>level</code> es una opci\u00f3n que espera un valor num\u00e9rico, pudiendo usarse de la forma <code>--level=3</code> o <code>-l 3</code>.</p>"},{"location":"en/es/user-guide/options-arguments/#proceso-de-parseo-y-conversion","title":"Proceso de Parseo y Conversi\u00f3n","text":"<p>Cuando se ejecuta un comando: 1. Parseo:    CliFire lee la l\u00ednea de comandos y separa los argumentos y opciones utilizando <code>shlex.split()</code>.    Los argumentos posicionados se asignan seg\u00fan el orden definido en la propiedad <code>_argument_names</code> del comando.</p> <ol> <li>Conversi\u00f3n de Valores:    Cada campo utiliza su m\u00e9todo <code>convert</code> para transformar el valor recibido de cadena a su tipo esperado.    Por ejemplo:</li> <li>Si se define el campo <code>level</code> con <code>force_type=int</code>, la cadena se convertir\u00e1 a entero.</li> <li> <p>Si el campo es de tipo <code>list</code>, se puede usar una separaci\u00f3n por comas para obtener una lista de elementos.</p> </li> <li> <p>Validaciones:</p> </li> <li>Si un campo es obligatorio (sin valor por defecto), se comprueba que se haya proporcionado un valor.</li> <li>Las opciones pueden tener alias; estos se normalizan (por ejemplo, eliminando guiones y reemplazando <code>-</code> por <code>_</code>) para evitar duplicados.</li> </ol>"},{"location":"en/es/user-guide/options-arguments/#ejecucion-de-un-comando-con-opciones-y-argumentos","title":"Ejecuci\u00f3n de un Comando con Opciones y Argumentos","text":"<p>Al ejecutar el comando anterior desde la terminal, podr\u00edas tener diferentes comportamientos:</p> <pre><code>$ fire test myfile.txt -v --level=5\n</code></pre> <ul> <li>El valor <code>\"myfile.txt\"</code> se asignar\u00e1 a <code>filename</code>.</li> <li>La opci\u00f3n <code>-v</code> har\u00e1 que <code>verbose</code> sea <code>True</code>.</li> <li>El argumento <code>--level=5</code> se convertir\u00e1 a entero (<code>5</code>) y se asignar\u00e1 a <code>level</code>.</li> </ul> <p>Si no se proporcionan algunos de estos valores, se utilizar\u00e1n los valores por defecto definidos.</p>"},{"location":"en/es/user-guide/options-arguments/#conclusion","title":"Conclusi\u00f3n","text":"<p>Gracias a esta estructura flexible, CliFire permite definir de forma sencilla c\u00f3mo se reciben y procesan los datos en tus comandos. Puedes combinar argumentos posicionados y opciones con alias, validaci\u00f3n y conversi\u00f3n autom\u00e1tica de tipos, lo que facilita la construcci\u00f3n de interfaces de l\u00ednea de comandos robustas y f\u00e1ciles de usar.</p> <p>\u00a1Experimenta creando tus propios comandos y ajustando las opciones seg\u00fan las necesidades de tu aplicaci\u00f3n!</p>"},{"location":"en/es/user-guide/output/","title":"M\u00f3dulo <code>out</code>: Salidas y Estilos","text":"<p>El m\u00f3dulo <code>out</code> de CliFire facilita la impresi\u00f3n de mensajes en la terminal con distintos estilos y colores, aprovechando la potencia de la biblioteca Rich. Con estas funciones podr\u00e1s mostrar informaci\u00f3n, advertencias, errores, mensajes de \u00e9xito, depuraciones y hasta actualizaciones en vivo.</p>"},{"location":"en/es/user-guide/output/#funciones-principales","title":"Funciones Principales","text":"<p>Importa el m\u00f3dulo <code>out</code> en tu aplicaci\u00f3n de la siguiente manera:</p> <p><pre><code>from clifire import out\n</code></pre> A continuaci\u00f3n, se describen las funciones m\u00e1s utilizadas:</p> <ul> <li> <p><code>out.info(text: str) -&gt; None</code>   Muestra un mensaje informativo.   <pre><code>out.info(\"This is an informational message\")\n</code></pre></p> </li> <li> <p><code>out.success(text: str) -&gt; None</code>   Muestra un mensaje de \u00e9xito, ideal para indicar que una operaci\u00f3n se complet\u00f3 correctamente.   <pre><code>out.success(\"Operation completed successfully\")\n</code></pre></p> </li> <li> <p><code>out.warn(text: str) -&gt; None</code>   Imprime un mensaje de advertencia, \u00fatil cuando se requiere precauci\u00f3n en la ejecuci\u00f3n.   <pre><code>out.warn(\"Warning: check your configuration\")\n</code></pre></p> </li> <li> <p><code>out.error(text: str) -&gt; None</code>   Muestra un mensaje de error de forma destacada para indicar fallos cr\u00edticos en el proceso.   <pre><code>out.error(\"Critical error occurred\")\n</code></pre></p> </li> <li> <p><code>out.debug(text: str) -&gt; None</code>   Imprime mensajes de depuraci\u00f3n, lo que resulta \u00fatil durante el desarrollo para rastrear el comportamiento interno.   <pre><code>out.debug(\"Debug: variable x = 42\")\n</code></pre></p> </li> <li> <p><code>out.var_dump(var) -&gt; None</code>   Imprime de manera legible el contenido de una variable, resaltando su estructura para facilitar su inspecci\u00f3n.   <pre><code>sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\nout.var_dump(sample_dict)\n</code></pre></p> </li> <li> <p><code>out.LiveText</code>   Es una clase que permite actualizar en vivo la salida de texto en la terminal. Es \u00fatil para mostrar barras de progreso o contadores que se actualizan din\u00e1micamente.   <pre><code>live_text = out.LiveText(\"Starting...\")\nlive_text.info(\"Process running\")\nlive_text.warn(\"Retrying operation\")\nlive_text.success(\"Operation completed\", end=False)\n</code></pre></p> </li> </ul>"},{"location":"en/es/user-guide/output/#uso-general","title":"Uso General","text":"<p>El m\u00f3dulo <code>out</code> est\u00e1 dise\u00f1ado para integrarse de forma transparente en tus comandos y aplicaciones creadas con CliFire, brindando un formato est\u00e1ndar y estilizado para la salida en la terminal. Cada funci\u00f3n aplica estilos predefinidos para mantener una experiencia consistente y atractiva.</p> <p>A continuaci\u00f3n, se muestra un ejemplo completo:</p> <pre><code>import time\n\nfrom clifire import application, command, out\n\n\nclass OutCommand(command.Command):\n    _name = 'out'\n\n    def fire(self):\n        print('Text colors')\n        print('-' * 80)\n        out.info(\"This is an informational message\")\n        out.success(\"Operation completed successfully\")\n        out.warn(\"Warning: check your configuration\")\n        out.error(\"Critical error occurred\")\n\n        print('')\n        print('Debug')\n        print('-' * 80)\n        out.debug(\"Debug: variable x = 42\")\n        sample_dict = {\"key\": \"value\", \"numbers\": [1, 2, 3]}\n        out.var_dump(sample_dict)\n\n        print('')\n        print('Tables')\n        print('-' * 80)\n        data = [\n            {\"name\": \"Luke\", \"age\": 18, \"is_student\": True},\n            {\"name\": \"Elizabeth\", \"age\": 101, \"is_student\": False},\n        ]\n        out.table(data, border=True, title=\"Contacts\")\n\n        print('')\n        print('Live text')\n        print('-' * 80)\n        live_text = out.LiveText(\"Starting...\")\n        time.sleep(1)\n        live_text.info(\"Process running\")\n        time.sleep(1)\n        live_text.warn(\"Retrying operation\")\n        time.sleep(1)\n        live_text.success(\"Operation completed\", end=False)\n        time.sleep(1)\n\n\ndef main():\n    app = application.App()\n    app.add_command(OutCommand)\n    app.fire(\"out -v\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p>"},{"location":"en/es/user-guide/output/#personalizacion","title":"Personalizaci\u00f3n","text":"<p>El m\u00f3dulo <code>out</code> utiliza un objeto de consola de Rich (<code>out.CONSOLE</code>) que puede ser personalizado. Si necesitas cambiar los estilos o modificar el comportamiento visual, puedes configurar dicho objeto o consultar la documentaci\u00f3n de Rich para m\u00e1s opciones.</p> <p>Con esta gu\u00eda tendr\u00e1s una visi\u00f3n general de c\u00f3mo utilizar el m\u00f3dulo <code>out</code> para mejorar la presentaci\u00f3n de mensajes en tus aplicaciones CLI creadas con CliFire.</p>"},{"location":"en/es/user-guide/templates/","title":"Plantillas en CliFire","text":"<p>El m\u00f3dulo <code>Template</code> de CliFire permite renderizar y guardar archivos usando plantillas basadas en Jinja2. Esta funcionalidad te ayuda a generar contenido din\u00e1mico de manera sencilla, ideal para crear archivos de configuraci\u00f3n, reportes u otros documentos que requieran personalizaci\u00f3n.</p> <p>Puede usar el m\u00f3dulo <code>Template</code> de manera independiente, o puede usarlo dentro de la clase <code>App</code> para manejar la configuraci\u00f3n de su aplicaci\u00f3n CLI.</p> <p>El fichero <code>sample_template/hello.jinja2</code> es un ejemplo de plantilla que se puede usar con el m\u00f3dulo <code>Template</code>. Aqu\u00ed tienes un ejemplo de c\u00f3mo se ver\u00eda el contenido de la plantilla:</p> <pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;ul&gt;\n    {% for number in numbers %}\n        &lt;li&gt;{{ number }}&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n</code></pre> <p>El comando CLI se llamar\u00e1 <code>app_template.py</code> y se ver\u00e1 as\u00ed: <pre><code>from clifire import application, command, out\n\n\nclass HelloCommand(command.Command):\n    _name = \"hello\"\n    _help = \"Create template\"\n\n    title = command.Field(\n        pos=1,\n        force_type=str,\n    )\n\n    def fire(self):\n        print(self.title)\n        content = self.app.template.render(\n            'hello.jinja2', title=self.title, numbers=[1, 2, 3])\n        out.success(content)\n\n\ndef main():\n    app = application.App(template_folder=\"./sample_template\")\n    app.add_command(HelloCommand)\n    app.fire()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Con esto al ejecutarlo tendr\u00e1s un comando que renderiza la plantilla <code>hello.jinja2</code> con el t\u00edtulo y una lista de n\u00fameros, mostrando el resultado en la terminal.</p> <p></p>"},{"location":"en/es/user-guide/templates/#funciones-principales","title":"Funciones Principales","text":"<ul> <li><code>Template.render(template: str, **args) -&gt; str</code>   Renderiza una plantilla especificada. Recibe el nombre del archivo de plantilla y par\u00e1metros adicionales que se utilizar\u00e1n para sustituir las variables definidas en la plantilla.</li> </ul> <p>Ejemplo:   <pre><code>from clifire import template\n\n# Crea el objeto Template especificando la carpeta donde se encuentran las plantillas.\ntpl = template.Template(\"templates\")\ncontent = tpl.render(\"sample.jinja2\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n\n# 'content' contendr\u00e1 el HTML generado con los valores proporcionados.\nprint(content)\n</code></pre></p> <ul> <li><code>Template.write(template: str, filename: str, mark: Optional[str] = None, **args) -&gt; str</code>   Renderiza la plantilla y guarda su contenido en un fichero.   Si se especifica un par\u00e1metro <code>mark</code>, el contenido renderizado se insertar\u00e1 o se reemplazar\u00e1 entre marcas especiales en el fichero; esto es \u00fatil para actualizar secciones espec\u00edficas sin sobrescribir el resto del contenido.</li> </ul> <p>Ejemplo sin marca:   <pre><code>tpl = template.Template(\"templates\")\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p> <p>Ejemplo con marca:   <pre><code>tpl = template.Template(\"templates\")\n# El marcado '&lt;&lt;CONTENT&gt;&gt;' delimitar\u00e1 la secci\u00f3n a actualizar.\nrendered = tpl.write(\"sample.jinja2\", \"output.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"My Title\", user=\"admin\", items=[\"one\", \"two\"])\n</code></pre></p>"},{"location":"en/es/user-guide/templates/#como-funciona","title":"\u00bfC\u00f3mo Funciona?","text":"<ol> <li> <p>Renderizado de Plantillas:    El m\u00e9todo <code>render</code> carga el archivo de plantilla utilizando Jinja2 y lo procesa con los argumentos proporcionados. Esto te permite generar contenido din\u00e1mico basado en variables definidas en tu plantilla.</p> </li> <li> <p>Guardado y Actualizaci\u00f3n de Archivos:    Con el m\u00e9todo <code>write</code>, puedes almacenar directamente el contenido renderizado en un fichero.    Si especificas un <code>mark</code>:</p> </li> <li>El m\u00e9todo busca dentro del fichero la secci\u00f3n delimitada por esa marca.</li> <li>Si encuentra la secci\u00f3n, la reemplaza con el nuevo contenido renderizado.</li> <li> <p>Si no existe, a\u00f1ade la secci\u00f3n al final del fichero.    Esto permite actualizar partes espec\u00edficas del fichero sin perder el contenido original que se encuentre fuera de las marcas.</p> </li> <li> <p>Integraci\u00f3n Din\u00e1mica:    El objeto <code>Template</code> se integra con el resto de CliFire, permiti\u00e9ndote utilizar variables de entorno o cualquier otra l\u00f3gica de negocio durante el renderizado.</p> </li> </ol>"},{"location":"en/es/user-guide/templates/#ejemplo-completo","title":"Ejemplo Completo","text":"<pre><code>from clifire import template\n\ndef generate_report():\n    # Inicializa la plantilla indicando la carpeta de plantillas\n    tpl = template.Template(\"templates\")\n\n    # Renderiza la plantilla sample.jinja2 con datos din\u00e1micos\n    content = tpl.render(\"sample.jinja2\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n    print(\"Rendered Content:\")\n    print(content)\n\n    # Guarda el contenido renderizado en output.html sin usar marcas\n    tpl.write(\"sample.jinja2\", \"output.html\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\n    # Guarda el contenido en output_marked.html utilizando una marca para actualizar solo una secci\u00f3n\n    tpl.write(\"sample.jinja2\", \"output_marked.html\", mark=\"&lt;&lt;CONTENT&gt;&gt;\", title=\"Report\", user=\"admin\", items=[\"Item 1\", \"Item 2\", \"Item 3\"])\n\nif __name__ == \"__main__\":\n    generate_report()\n</code></pre>"},{"location":"en/es/user-guide/templates/#conclusion","title":"Conclusi\u00f3n","text":"<p>El m\u00f3dulo <code>Template</code> permite separar la l\u00f3gica del contenido de la presentaci\u00f3n, facilitando la generaci\u00f3n de ficheros din\u00e1micos a partir de plantillas. Esto mejora la mantenibilidad y la flexibilidad de tus aplicaciones CLI, permiti\u00e9ndote actualizar secciones espec\u00edficas de un fichero sin afectar el resto del contenido.</p> <p>Esta funcionalidad es especialmente \u00fatil para proyectos que requieran la creaci\u00f3n o actualizaci\u00f3n peri\u00f3dica de reportes, ficheros de configuraci\u00f3n, o cualquier otro tipo de documento basado en plantillas.</p>"}]}